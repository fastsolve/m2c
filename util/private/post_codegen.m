function changed = post_codegen(func, cpath, m2c_opts)
%% Modify function generated by codegen
    
if m2c_opts.gen64
    warning('Conversion to 64 bit is not fully supported. Use at your own risk.');
    convert64(cpath);
end

filename = [cpath func '.' m2c_opts.suf];
str = readFile(filename);

str0 = str;

% Remove declaration of emxEnsureCapacity
str = regexprep(str, 'static\s+void\s+emxEnsureCapacity\s*\([^,\)]+,[^,\)]+,[^,\)]+\);\n', '');
str = regexprep(str, ['(static\s+)?void\s+emxEnsureCapacity\s*\([^,\)]+,[^,\)]+,[^,\)]+\)\s*' funcbody ], '');

basictype = '(boolean_T|char_T|int8_T|int16_T|int32_T|int64_T|uint8_T|uint16_T|uint32_T|uint64_T|real_T|real32_T|real64_T)';

% Remove declaration of emxInit_basictype and emxFree_basictype for basic types
ks = strfind(filename, '.');
ctype_filename = [filename(1:ks(end)-1), '_types.h'];
ctypes = readFile(ctype_filename);

tokens = regexp(ctypes, ['struct\s+emxArray_(' basictype ')'], 'tokens');
for i=1:length(tokens)
    str = regexprep(str, ['static\s+void\s+emxInit_' ...
        tokens{i}{1} '\([^,\)]+,[^,\)]+\);\n'], '');   
    str = regexprep(str, ['static\s+void\s+emxInit_' ...
        tokens{i}{1} '\([^,\)]+,[^,\)]+\)\s*' funcbody], '');   

    str = regexprep(str, ['static\s+void\s+emxFree_' ...
        tokens{i}{1} '\([^,\)]+\);\n'], '');
    str = regexprep(str, ['static\s+void\s+emxFree_' ...
        tokens{i}{1} '\([^,\)]+\)\s*' funcbody], '');   
end

% Remove declaration of emxCreate_basictype, emxCreateND_basictype, 
% and emxCreateWrapperND_basictype, emxDestroyArray_basictype
str = regexprep(str, ['emxArray_\w+\s+\*emxCreate_' basictype ...
    '\([^,\)]+,[^,\)]+\)\s*' funcbody], '');
str = regexprep(str, ['emxArray_\w+\s+\*emxCreateND_' basictype ...
    '\([^,\)]+,[^,\)]+\)\s*' funcbody], '');
str = regexprep(str, ['emxArray_\w+\s+\*emxCreateWrapper_' basictype ...
    '\([^,\)]+,[^,\)]+,[^,\)]+\)\s*' funcbody], '');
str = regexprep(str, ['emxArray_\w+\s+\*emxCreateWrapperND_' basictype ...
    '\([^,\)]+,[^,\)]+,[^,\)]+\)\s*' funcbody], '');
str = regexprep(str, ['void\s+emxDestroyArray_' basictype ...
    '\([^,\)]+\)\s*' funcbody], '');


% Remove declaration of emxCreate_struct, emxCreateND_struct, 
% and emxCreateWrapperND_struct, emxDestroyArray_struct
str = regexprep(str, ['emxArray_(\w+)\s+\*emxCreate_\w+\s*' ...
    '\([^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreate($2, $1)');
str = regexprep(str, ['emxArray_(\w+)\s+\*emxCreateND_\w+\s*' ...
    '\([^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreateND($2, $1)');
str = regexprep(str, ['emxArray_(\w+)\s+\*emxCreateWrapper_\w+\s*' ...
    '\(\s*(\w+)[^,\)]+,[^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreateWrapper($3, $1, $2)');
str = regexprep(str, ['emxArray_(\w+)\s+\*emxCreateWrapperND_\w+\s*' ...
    '\(\s*(\w+)[^,\)]+,[^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreateWrapperND($3, $1, $2)');
str = regexprep(str, ['void\s+emxDestroyArray_(\w+)\s*' ...
    '\([^,\)]+\)\s*{\s+(\w*emxFree_\w+)\s*\([^\)]+\);\s+}'], ...
    'define_emxDestroyArray($2, $1)');

% Remove definition of emxArray__common
str = regexprep(str, ['#ifndef\s+struct_emxArray__common\s+'...
    '#define\s+struct_emxArray__common\s+struct\s+emxArray__common\s+{[^}]+};\s+' ...
    '#endif\s+#ifndef\s+typedef_emxArray__common\s+#define\s+typedef_emxArray__common\s+' ...
    'typedef\s+struct\s+emxArray__common\s+emxArray__common;\s+#endif\n'], '');

% Omit declaration of variable references.
str = regexprep(str, '\n#ref\([^\)]+\);', '');

if exist('replace_pragmas', 'file')
    str = replace_pragmas(str);
end

% Remove two consecutive empty lines
while ~isempty(regexp(str, '\n\n\n', 'once'))
    str = regexprep(str, '(\n\n)\n', '$1');
end

% Check emxCopyStruct
check_emxCopyStruct(str);

% Check copying of constant input arrays
check_inputArrays(str);

% Check allocation of local arrays
check_localArrays(str);

% Check casting of integers
check_intCasting(str);

changed = ~isequal(str, str0);
if changed
    writeFile(filename, str);
end

end

function check_emxCopyStruct(str)
% Disable emxCopyStruct

funcs = regexp(str, '(\w+)(\([^)]+\))\s*({([^}][^\n]*\n)+\s+(?:\w+_)?emxCopyStruct_\w+\(&\w+,\s*\w+\);([^}][^\n]*\n)+})', 'tokens');

for i=1:length(funcs)
    % Remove emxCopyStruct_ from the function.
    funname = funcs{i}{1};
    args = funcs{i}{2};
    fun = funcs{i}{3};
    
    if ~isempty(strfind(funname, 'emlrt_')); continue; end
    toks = regexp(fun, '\s+(?:\w+_)?emxCopyStruct_(\w+)\(&(\w+),\s*(\w+)\);', 'tokens');
    
    for j=1:length(toks)
        assert(isequal([ '_' toks{j}{3}], toks{j}{2}(end-length(toks{j}{3}):end)));
        
        % Check input arguments to see whether the object is defined as const
        if ~isempty(regexp(args, ['\sconst\s+' toks{j}{1} '\w*\s*\*?\s*' toks{j}{3}], 'once'))
            warning('m2c:StructCopyConst', ['Function "%s" modifies an input struct object "%s". ' ...
                'For better performance, make this object an output as well, '...
                'and when calling the function, use a same variable '...
                'on the left- and right-hand side for this argument.'], funname, toks{j}{2});
            continue;
        end
        
        if isempty(regexp(args, ['[^\w\s]\s*' toks{j}{1} '\w*\s*\*\s*' toks{j}{3}], 'once'))
            warning('m2c:StructCopy', 'Function "%s" copies a local struct object "%s".', funname, toks{j}{2});
            continue;
        end
        
        assert(~isempty(regexp(fun, '\s+(?:\w+_)?emxCopyStruct_(\w+)\((\w+),\s*&(\w+)\);', 'once')));
        
        % Check whether there is assignment to itself
        if ~isempty(regexp(fun, [toks{j}{3} '->\w+([\w\[\]->\.])?\s*=\s*' toks{j}{2} '\.\w+([\w\[\]->\.])?;'], 'once')) || ...
                ~isempty(regexp(fun, [toks{j}{2} '\.\w+([\w\[\]->\.])?\s*=\s*' toks{j}{3} '->\w+([\w\[\]->\.])?;'], 'once'))
            warning('m2c:StructCopy', ['m2c Info: Function "%s" copies the output struct object "%s" into a local variable "%s". ' ...
                'm2c cannot optmize it. Please rewrite the MATLAB function to modify the object in a subfunction.'], ...
                funname, toks{j}{3}, toks{j}{2});
            continue;
        end
        
        body = regexprep(fun, ['\n\s+\w*emxCopyStruct_' toks{j}{1} '\w*\(' toks{j}{3} ',\s*\&' toks{j}{2} '\);'], char(187));
        smallbody = ['\n\s+\w*emxCopyStruct_' toks{j}{1} '\w*\(\&' toks{j}{2} ',\s*' toks{j}{3} '\);([^' char(187) ']+)' char(187)];
        
        body = regexp(body, smallbody, 'tokens');
        if isempty(body); continue; end
        
        hasinline = false;
        for k=1:length(body)
            if ~isempty(regexp(body{k}{1}, ['(\n\s+[^\n]*[^\w])' toks{j}{2} '\.(\w+)'], 'once'))
                warning('m2c:StructCopyFailed', ['Could not strip out copying of "' funname '", ' ...
                    'because the following inlined code "' body{k}{1} '". '...
                    'Please disable inlining by inserting coder.inline(''never'') into the MATLAB function corresponds to this code segment.']);
                hasinline = true;
                break;
            end
        end
        if hasinline; continue; end
    end
end
end

function check_inputArrays(str)
% Check input constant arrays

funcs = regexp(str, ['(\w+)(\([^\)]+const emxArray_[^\)]+\))\s*(' funcbody ')'], 'tokens');

for i=1:length(funcs)
    % Check whether an argument is copied.
    funname = funcs{i}{1};
    args = funcs{i}{2};
    fun = funcs{i}{3};
    if ~isempty(strfind(funname, 'emlrt_')); continue; end
    
    toks = regexp(args, 'const emxArray_(\w+)\s*\*\s*(\w+)', 'tokens');
    for j=1:length(toks)
        
        % Check to see whether the array has a copy defined.
        if isempty(strfind(toks{j}{2}, '_')) && ~isempty(regexp(fun, ...
                ['\semxArray_' toks{j}{1} '\s*\*\s*\w+_' toks{j}{2} ';'], 'once'))
            warning('m2c:ConstArrayCopyConst', ['Function "%s" makes a copy of an input array "%s". ' ...
                'For better performance, make this array an output as well, '...
                'and when calling the function, use a same variable '...
                'on the left- and right-hand side for this argument.'], funname, toks{j}{2});
        end
    end
end
end

function check_localArrays(str)
funcs = regexp(str, ['(\w+)(\([^\)]+\))\s*(' funcbody ')'], 'tokens');

dir = 'lib';

for i=1:length(funcs)
    % Check whether an argument is copied.
    funname = funcs{i}{1};
    % args = funcs{i}{2};
    fun = funcs{i}{3};
    
    if ~isempty(strfind(funname, 'emlrt_')); continue; end
    toks = regexp(fun, '\s+emxEnsureCapacity\(\(emxArray__common \*\)(r[\d]+),\s*\w+,\s*\(int32_T\)', 'tokens');
    
    for j=1:length(toks)
        % Check to see whether the variables are used as local indices
        target = regexp(fun, ['\s+(\w+)->data\[\w+\] = [\w->]+->data\[' toks{j}{1} '->data\[\w+\] - 1\]'], 'tokens');
        if ~isempty(target)
            fprintf(2, ['m2c Info: Function "%s" created a local integer buffer for the assignment of array "%s". '...
                'This probably indicates that you are assigning to a submatrix or a subvector of some variable size. ' ...
                'Current version of MATLAB Coder does not generate very efficient code for it. ' ...
                'Please review the generated C code codegen/%s/%s/%s.c and the MATLAB code, and consider replacing the assignment ' ...
                'in the MATLAB code with an explict for loop for better efficiency of the C code.\n'], ...
                funname, target{1}{1}, dir, funname, funname);
        else
            skip=false;
            for k=1:j-1
                if isequal(toks{j}{1},toks{k}{1}); skip=true; end
            end
            if skip;
                continue;
            end
            target = regexp(fun, [toks{j}{1} '->data\[\w+\] = ([\w->]+)->data\[\w+\]'], 'tokens');
            if ~isempty(target)
                fprintf(2, 'm2c Info: Function "%s" created a local buffer as a local copy of array "%s".\n', ...
                    funname, target{1}{1});
            else
                fprintf(2, 'm2c Info: Function "%s" created a local buffer "%s".\n', ...
                    funname, toks{j}{1});
            end
        end
    end
end

end

function check_intCasting(str)

funcs = regexp(str, ['(\w+)(\([^\)]+\))\s*(' funcbody ')'], 'tokens');

for i=1:length(funcs)
    % Check whether an argument is copied.
    funname = funcs{i}{1};
    fun = funcs{i}{3};
    
    toks = regexp(fun, '(\w+)\s*=\s*\(int32_T\)floor\(', 'tokens');
    for j=1:length(toks)
        fprintf(2, 'm2c Info: Function "%s" involves casting from a real value to integer variable "%s".\n', ...
            funname, toks{j}{1});
    end
end
end

function fb = funcbody
fb = '{(?:[^}][^\n]*\n)*\n*}';
end
