function changed = post_codegen(func, cpath, m2c_opts)
%% Modify files generated by codegen

cfilename = [cpath func '.' m2c_opts.suf];
cfile_str = readFile(cfilename);

ks = strfind(cfilename, '.');
h_filename = [cfilename(1:ks(end)-1), '.h'];
hfile_str = readFile(h_filename);

ctype_filename = [cfilename(1:ks(end)-1), '_types.h'];
ctypes_str = readFile(ctype_filename);

% Check whether the C file includes m2c.h
usem2c = ~isempty(regexp(cfile_str, '\n#include "m2c.h"', 'once'));

cfile_str_orig = cfile_str;

%% Move type declarations from C file to header file
% Remove definition of emxArray__common
cfile_str = regexprep(cfile_str, ['#ifndef\s+struct_emxArray__common\s+'...
    '#define\s+struct_emxArray__common\s+struct\s+emxArray__common\s+{[^}]+};\s+' ...
    '#endif\s+#ifndef\s+typedef_emxArray__common\s+#define\s+typedef_emxArray__common\s+' ...
    'typedef\s+struct\s+emxArray__common\s+' ...
    'emxArray__common;\s+#endif\n'], '');

[cfile_str, type_def] = move_type_decl(cfile_str);

if ~isempty(type_def)
    if m2c_opts.verbose
        % Move type definitions
        fprintf('M2C: API functions involves structures. Moved type definitions into header file %s_types.h\n', func);
    end
    
    if ~isempty(strfind(ctypes_str, '/* End of code generation'))
        ctypes_str = strrep(ctypes_str, ...
            sprintf('\n#endif\n\n/* End of code generation'), ...
            [sprintf('%s\n', '', '', ...
            '/* Type Declarations inserted by m2c */', type_def, ...
            '#endif', '') '/* End of code generation']);
    else
        ctypes_str = regexprep(ctypes_str, '(\n#endif\n*$)', [type_def '$1']);
    end
    writeFile(ctype_filename, ctypes_str);
end

%% Remove functions for standard data types
basictype = '(boolean_T|char_T|int8_T|int16_T|int32_T|int64_T|uint8_T|uint16_T|uint32_T|uint64_T|real_T|real32_T|real64_T)';

% Remove declaration of emxEnsureCapacity
cfile_str = regexprep(cfile_str, 'static\s+void\s+emxEnsureCapacity\s*\([^,\)]+,[^,\)]+,[^,\)]+\);\n', '');
cfile_str = regexprep(cfile_str, ['(static\s+)?void\s+' ...
    'emxEnsureCapacity\s*\([^,\)]+,[^,\)]+,[^,\)]+\)\s*' funcbody ], '');

% Remove declaration of emxInit_basictype and emxFree_basictype for basic types
tokens = regexp(ctypes_str, ['struct\s+emxArray_(' basictype ')'], 'tokens');
for i=1:length(tokens)
    cfile_str = regexprep(cfile_str, ['static\s+void\s+emxInit_' ...
        tokens{i}{1} '\d*\([^,\)]+,[^,\)]+\);\n'], '');
    cfile_str = regexprep(cfile_str, ['static\s+void\s+emxInit_' ...
        tokens{i}{1} '\d*\([^,\)]+,[^,\)]+\)\s*' funcbody], '');
    % Replace calls to emxInit_<type>\d by emxInit_<type>
    cfile_str = regexprep(cfile_str, ['(\s+emxInit_' tokens{i}{1} ')\d+\('], '$1(');
    
    cfile_str = regexprep(cfile_str, ['static\s+void\s+emxFree_' ...
        tokens{i}{1} '\([^,\)]+\);\n'], '');
    cfile_str = regexprep(cfile_str, ['static\s+void\s+emxFree_' ...
        tokens{i}{1} '\([^,\)]+\)\s*' funcbody], '');
end

% Remove declaration of emxCreate_basictype, emxCreateND_basictype,
% and emxCreateWrapperND_basictype, emxDestroyArray_basictype
cfile_str = regexprep(cfile_str, ['emxArray_\w+\s+\*emxCreate_' basictype ...
    '\([^,\)]+,[^,\)]+\)\s*' funcbody], '');
cfile_str = regexprep(cfile_str, ['emxArray_\w+\s+\*emxCreateND_' basictype ...
    '\([^,\)]+,[^,\)]+\)\s*' funcbody], '');
cfile_str = regexprep(cfile_str, ['emxArray_\w+\s+\*emxCreateWrapper_' basictype ...
    '\([^,\)]+,[^,\)]+,[^,\)]+\)\s*' funcbody], '');
cfile_str = regexprep(cfile_str, ['emxArray_\w+\s+\*emxCreateWrapperND_' basictype ...
    '\([^,\)]+,[^,\)]+,[^,\)]+\)\s*' funcbody], '');
cfile_str = regexprep(cfile_str, ['void\s+emxDestroyArray_' basictype ...
    '\([^,\)]+\)\s*' funcbody], '');

% Remove declaration of emxCreate_struct, emxCreateND_struct,
% and emxCreateWrapperND_struct, emxDestroyArray_struct
cfile_str = regexprep(cfile_str, ['emxArray_(\w+)\s+\*emxCreate_\w+\s*' ...
    '\([^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreate($2, $1)');
cfile_str = regexprep(cfile_str, ['emxArray_(\w+)\s+\*emxCreateND_\w+\s*' ...
    '\([^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreateND($2, $1)');
cfile_str = regexprep(cfile_str, ['emxArray_(\w+)\s+\*emxCreateWrapper_\w+\s*' ...
    '\(\s*(\w+)[^,\)]+,[^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreateWrapper($3, $1, $2)');
cfile_str = regexprep(cfile_str, ['emxArray_(\w+)\s+\*emxCreateWrapperND_\w+\s*' ...
    '\(\s*(\w+)[^,\)]+,[^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreateWrapperND($3, $1, $2)');
cfile_str = regexprep(cfile_str, ['void\s+emxDestroyArray_(\w+)\s*' ...
    '\([^,\)]+\)\s*{\s+(\w*emxFree_\w+)\s*\([^\)]+\);\s+}'], ...
    'define_emxDestroyArray($2, $1)');

% Add '#include "m2c.h"' if needed
if ~usem2c && length(cfile_str) ~= length(cfile_str_orig)
    cfile_str = regexprep(cfile_str, ['(^|\n)(#include\s+"' func '.h"\n)'], ...
        '$1$2#include "m2c.h"\n');
end

%% Omit declaration of variable references and replace pragma
cfile_str = regexprep(cfile_str, '\n#ref\([^\)]+\);', '');

if exist('replace_pragmas', 'file')
    cfile_str = replace_pragmas(cfile_str, m2c_opts);
end

%% Change API definitinons.
api_decl = '';
for i=1:length(m2c_opts.api)
    [cfile_str, api_decl] = move_api_declaration(m2c_opts.api{i}, ...
        cfile_str, api_decl);
    
    cfile_str = change_api_definition(m2c_opts.api{i}, cfile_str);
    fprintf('M2C: Moved API function %s into header file\n', m2c_opts.api{i});
end

if ~isempty(api_decl)
    hfile_str = strrep(hfile_str, ...
        sprintf('\n#endif\n\n/* End of code generation'), ...
        [sprintf('%s\n', '', ...
        ['/* API Function Declarations inserted inserted by m2c */', api_decl], '', ...
        '#endif', '') '/* End of code generation']);
    
    pat = '\s+(emxArray_\w*struct\w*_T)\s+\*';
    public_types = regexp(api_decl, '\s+emxArray_\w*struct\w*_T\s+\*', 'match');
    for i=1:length(public_types)
        public_types{i} = regexprep(public_types{i}, pat, '$1');
    end
    
    if ~isempty(public_types)
        % Move emxInit_ and emxFree_ of public data types into the header file
        [cfile_str, hfile_str] = move_emx_decl(cfile_str, hfile_str, public_types);
    end
    
    writeFile(h_filename, hfile_str);
end

% Remove two consecutive empty lines and empty functions
while ~isempty(regexp(cfile_str, '\n\n\n', 'once'))
    cfile_str = regexprep(cfile_str, '(\n\n)\n', '$1');
end
cfile_str = regexprep(cfile_str, '(\{\n)\n+(\})', '$1$2');

% Write C file
if ~isequal(cfile_str, cfile_str_orig)
    writeFile(cfilename, cfile_str);
    changed = true;
end

%% Perform some checkings on performance
if m2c_opts.debugInfo && ~m2c_opts.quiet
    % Check copying of constant input arrays
    check_inputArrays(cfile_str);
    
    % Check allocation of local arrays
    check_localArrays(cfile_str);
    
    % Check casting of integers
    check_intCasting(cfile_str);
    
    % TODO Check integer division
end

end

function check_inputArrays(str)
% Check input constant arrays

funcs = regexp(str, ['(\w+)(\([^\)]+const emxArray_[^\)]+\))\s*(' funcbody ')'], 'tokens');

for i=1:length(funcs)
    % Check whether an argument is copied.
    funname = funcs{i}{1};
    args = funcs{i}{2};
    fun = funcs{i}{3};
    if ~isempty(strfind(funname, 'emlrt_')); continue; end
    
    toks = regexp(args, 'const emxArray_(\w+)\s*\*\s*(\w+)', 'tokens');
    for j=1:length(toks)
        
        % Check to see whether the array has a copy defined.
        if isempty(strfind(toks{j}{2}, '_')) && ~isempty(regexp(fun, ...
                ['\semxArray_' toks{j}{1} '\s*\*\s*\w+_' toks{j}{2} ';'], 'once'))
            warning('m2c:ConstArrayCopyConst', ['Function "%s" makes a copy of an input array "%s". ' ...
                'For better performance, make this array an output as well, '...
                'and when calling the function, use a same variable '...
                'on the left- and right-hand side for this argument.'], funname, toks{j}{2});
        end
    end
end
end

function check_localArrays(str)
funcs = regexp(str, ['(\w+)(\([^\)]+\))\s*(' funcbody ')'], 'tokens');

dir = 'lib';

for i=1:length(funcs)
    % Check whether an argument is copied.
    funname = funcs{i}{1};
    % args = funcs{i}{2};
    fun = funcs{i}{3};
    
    if ~isempty(strfind(funname, 'emlrt_')); continue; end
    toks = regexp(fun, '\s+emxEnsureCapacity\(\(emxArray__common \*\)(r[\d]+),\s*\w+,\s*\(int32_T\)', 'tokens');
    
    for j=1:length(toks)
        % Check to see whether the variables are used as local indices
        target = regexp(fun, ['\s+(\w+)->data\[\w+\] = [\w->]+->data\[' toks{j}{1} '->data\[\w+\] - 1\]'], 'tokens');
        if ~isempty(target)
            fprintf(2, ['m2c Info: Function "%s" created a local integer buffer for the assignment of array "%s". '...
                'This probably indicates that you are assigning to a submatrix or a subvector of some variable size. ' ...
                'Current version of MATLAB Coder does not generate very efficient code for it. ' ...
                'Please review the generated C code codegen/%s/%s/%s.c and the MATLAB code, and consider replacing the assignment ' ...
                'in the MATLAB code with an explict for loop for better efficiency of the C code.\n'], ...
                funname, target{1}{1}, dir, funname, funname);
        else
            skip=false;
            for k=1:j-1
                if isequal(toks{j}{1},toks{k}{1}); skip=true; end
            end
            if skip;
                continue;
            end
            target = regexp(fun, [toks{j}{1} '->data\[\w+\] = ([\w->]+)->data\[\w+\]'], 'tokens');
            if ~isempty(target)
                fprintf(2, 'm2c Info: Function "%s" created a local buffer as a local copy of array "%s".\n', ...
                    funname, target{1}{1});
            else
                fprintf(2, 'm2c Info: Function "%s" created a local buffer "%s".\n', ...
                    funname, toks{j}{1});
            end
        end
    end
end

end

function check_intCasting(str)

funcs = regexp(str, ['(\w+)(\([^\)]+\))\s*(' funcbody ')'], 'tokens');

for i=1:length(funcs)
    % Check whether an argument is copied.
    funname = funcs{i}{1};
    fun = funcs{i}{3};
    
    toks = regexp(fun, '(\w+)\s*=\s*\(int32_T\)floor\(', 'tokens');
    for j=1:length(toks)
        fprintf(2, 'm2c Info: Function "%s" involves casting from a real value to integer variable "%s".\n', ...
            funname, toks{j}{1});
    end
end
end

function fb = funcbody
fb = '{(?:[^}][^\n]*\n)*\n*}';
end

function [cfile, hfile] = move_api_declaration(func, cfile, hfile)
% Move a particlar API function declaration from C to h

% Find function declaration
pat = ['\n\s*static\s+\w+\s+' func '\s*\(([^)]*)\);'];
decl = regexp(cfile, pat, 'match', 'once');

if isempty(decl)
    fprintf(['Could not find the API function %s in the generated C code.\n Please make sure the ' ...
        'function is not inlined by adding coder.inline(''never'') in the M code.'], func);
else
    % Remove it from C file
    cfile = strrep(cfile, decl, '');
    
    % replace static by extern
    new_decl = [decl(1), 'extern', decl(8:end)];
    
    % Add the declaration to the header file
    hfile = [hfile, new_decl];
end

end

function cfile = change_api_definition(func, cfile)
% Change the definition of the function in the C code

% Find function declaration
pat = ['(\n\s*)static\s+(\w+\s+' func '\s*\(([^)]*)\)\s*{)'];
defs = regexp(cfile, pat, 'match', 'once');

if isempty(defs)
    fprintf(['Did not find API function %s in the generated C code.\n Please check ' ...
        'whether the function is used and is marked as coder.inline(''never'').'], func);
else
    new_def = regexprep(defs, pat, '$1$2');
    
    spaces = repmat(' ', 1, length(defs)-length(new_def));
    % Remove spaces
    new_def = strrep(new_def, [defs(1) spaces], defs(1));
    
    % Add the declaration to the header file
    cfile = strrep(cfile, defs, new_def);
end
end

function [cfile, type_def] = move_type_decl(cfile)
% Find function declaration
pat = '\n\/\* Type Definitions \*\/\n.+\n\/\* Function Declarations \*\/\n';
comment = regexp(cfile, pat, 'match', 'once');

if ~isempty(comment)
    % Remove it from C file
    cfile = strrep(cfile, comment, ...
        sprintf('\n%s', '/* Function Declarations */', ''));
    
    type_def = comment(25:end-30);
else
    % Move type declarations from C code to the _types.h header file.
    pat = ['#ifndef\s+\w+\n+\#define\s+\w+\n+struct\s+\w+\s+\{([^}][^\n]+\n)+\};\n+#endif\n+' ...
        '#ifndef\s+typedef_\w+\n+#define\s+\w+\n+typedef\s+struct\s+\w+\s+\w+;\n+#endif'];
    
    types = regexp(cfile, pat, 'match');
    type_def = '';
    for i=1:length(types)
        cfile = strrep(cfile, types{i}, '');
        type_def = sprintf('%s\n', type_def, types{i});
    end
end
end

function [cfile_str, hfile_str] = move_emx_decl(cfile_str, hfile_str, public_types)
% Move emxFree_ and emxInit_ declarations from C code to the _types.h header file.
types = sprintf('%s|', public_types{:});

% Find declaration of emxInit_struct_T and and emxFree_struct_T
pat = ['\n\s*static\s+void\s+(emx(Init|Free)_struct_\w+)\s*\((' types(1:end-1) ')([^)]*)\);'];
emx_API = regexp(cfile_str, pat, 'match');

emx_decl = '';
for i=1:length(emx_API)
    func = regexprep(emx_API{i}, pat, '$1');
    [cfile_str, emx_decl] = move_api_declaration(func, cfile_str, emx_decl);
    
    cfile_str = change_api_definition(func, cfile_str);
    fprintf('M2C: Moved helper function %s into header file\n', func);
end

hfile_str = strrep(hfile_str, ...
    sprintf('\n#endif\n\n/* End of code generation'), ...
    [sprintf('%s\n', '', ...
    ['/* emx Function Declarations inserted inserted by m2c */', emx_decl], '', ...
    '#endif', '') '/* End of code generation']);
end
