/*
 * codegen/lib/cuGetDeviceProperties/cuGetDeviceProperties_mex.c
 *
 * Auxiliary code for mexFunction of cuGetDeviceProperties
 *
 * C source code generated by m2c.
 * %#m2c options:b318e69f60b10d635f01d3f0f296d088
 *
 */

#include "mex.h"
#if !defined(MATLAB_MEX_FILE) && defined(printf)
#undef printf
#endif
/* Include the C header file generated by codegen in lib mode */
#include "cuGetDeviceProperties.h"
#include "m2c.c"

/* Include declaration of some helper functions. */
#include "lib2mex_helper.c"

static void prealloc_struct0_T(struct0_T *pStruct) {


    pStruct->name = mxMalloc(sizeof(emxArray_char_T));
    init_emxArray((emxArray__common*)(pStruct->name), 2);

















}
static mxArray *marshallout_struct0_T(struct0_T *pStruct) {
    const char           *fields[] = {"name", "multiProcessorCount", "maxThreadsPerMultiProcessor", "maxThreadsPerBlock", "warpSize", "concurrentKernels", "totalGlobalMem", "sharedMemPerBlock", "sharedMemPerMultiprocessor", "totalConstMem", "clockRate", "asyncEngineCount", "computeMode", "major", "minor", "maxGridSize", "maxThreadsDim", "isMultiGpuBoard", "canMapHostMemory", "managedMemory", "unifiedAddressing", "globalL1CacheSupported", "l2CacheSize", "regsPerBlock", "regsPerMultiprocessor", "memoryBusWidth", "memoryClockRate", "memPitch", "textureAlignment", "deviceOverlap", "kernelExecTimeoutEnabled", "integrated", "ECCEnabled", "pciBusID", "tccDriver"};
    int                  one=1;
    mxArray              *mx = create_struct_mxArray(1, &one, 35, fields);
    int                  _dims[2];

    mxSetField(mx, 0, "name", move_emxArray_to_mxArray((emxArray__common*)(pStruct->name), mxCHAR_CLASS));
    mxFree(pStruct->name->size);
    mxFree(pStruct->name);

    mxSetField(mx, 0, "multiProcessorCount", copy_scalar_to_mxArray(&pStruct->multiProcessorCount, mxINT32_CLASS));
    mxSetField(mx, 0, "maxThreadsPerMultiProcessor", copy_scalar_to_mxArray(&pStruct->maxThreadsPerMultiProcessor, mxINT32_CLASS));
    mxSetField(mx, 0, "maxThreadsPerBlock", copy_scalar_to_mxArray(&pStruct->maxThreadsPerBlock, mxINT32_CLASS));
    mxSetField(mx, 0, "warpSize", copy_scalar_to_mxArray(&pStruct->warpSize, mxINT32_CLASS));
    mxSetField(mx, 0, "concurrentKernels", copy_scalar_to_mxArray(&pStruct->concurrentKernels, mxINT32_CLASS));
    mxSetField(mx, 0, "totalGlobalMem", copy_scalar_to_mxArray(&pStruct->totalGlobalMem, mxUINT64_CLASS));
    mxSetField(mx, 0, "sharedMemPerBlock", copy_scalar_to_mxArray(&pStruct->sharedMemPerBlock, mxUINT64_CLASS));
    mxSetField(mx, 0, "sharedMemPerMultiprocessor", copy_scalar_to_mxArray(&pStruct->sharedMemPerMultiprocessor, mxUINT64_CLASS));
    mxSetField(mx, 0, "totalConstMem", copy_scalar_to_mxArray(&pStruct->totalConstMem, mxUINT64_CLASS));
    mxSetField(mx, 0, "clockRate", copy_scalar_to_mxArray(&pStruct->clockRate, mxINT32_CLASS));
    mxSetField(mx, 0, "asyncEngineCount", copy_scalar_to_mxArray(&pStruct->asyncEngineCount, mxINT32_CLASS));
    mxSetField(mx, 0, "computeMode", copy_scalar_to_mxArray(&pStruct->computeMode, mxINT32_CLASS));
    mxSetField(mx, 0, "major", copy_scalar_to_mxArray(&pStruct->b_major, mxINT32_CLASS));
    mxSetField(mx, 0, "minor", copy_scalar_to_mxArray(&pStruct->b_minor, mxINT32_CLASS));
    _dims[0] = 1;
    _dims[1] = 3;
    mxSetField(mx, 0, "maxGridSize", copy_array_to_mxArray(pStruct->maxGridSize, mxINT32_CLASS, 2, _dims));
    _dims[0] = 1;
    _dims[1] = 3;
    mxSetField(mx, 0, "maxThreadsDim", copy_array_to_mxArray(pStruct->maxThreadsDim, mxINT32_CLASS, 2, _dims));
    mxSetField(mx, 0, "isMultiGpuBoard", copy_scalar_to_mxArray(&pStruct->isMultiGpuBoard, mxINT32_CLASS));
    mxSetField(mx, 0, "canMapHostMemory", copy_scalar_to_mxArray(&pStruct->canMapHostMemory, mxINT32_CLASS));
    mxSetField(mx, 0, "managedMemory", copy_scalar_to_mxArray(&pStruct->managedMemory, mxINT32_CLASS));
    mxSetField(mx, 0, "unifiedAddressing", copy_scalar_to_mxArray(&pStruct->unifiedAddressing, mxINT32_CLASS));
    mxSetField(mx, 0, "globalL1CacheSupported", copy_scalar_to_mxArray(&pStruct->globalL1CacheSupported, mxINT32_CLASS));
    mxSetField(mx, 0, "l2CacheSize", copy_scalar_to_mxArray(&pStruct->l2CacheSize, mxINT32_CLASS));
    mxSetField(mx, 0, "regsPerBlock", copy_scalar_to_mxArray(&pStruct->regsPerBlock, mxINT32_CLASS));
    mxSetField(mx, 0, "regsPerMultiprocessor", copy_scalar_to_mxArray(&pStruct->regsPerMultiprocessor, mxINT32_CLASS));
    mxSetField(mx, 0, "memoryBusWidth", copy_scalar_to_mxArray(&pStruct->memoryBusWidth, mxINT32_CLASS));
    mxSetField(mx, 0, "memoryClockRate", copy_scalar_to_mxArray(&pStruct->memoryClockRate, mxINT32_CLASS));
    mxSetField(mx, 0, "memPitch", copy_scalar_to_mxArray(&pStruct->memPitch, mxUINT64_CLASS));
    mxSetField(mx, 0, "textureAlignment", copy_scalar_to_mxArray(&pStruct->textureAlignment, mxUINT64_CLASS));
    mxSetField(mx, 0, "deviceOverlap", copy_scalar_to_mxArray(&pStruct->deviceOverlap, mxINT32_CLASS));
    mxSetField(mx, 0, "kernelExecTimeoutEnabled", copy_scalar_to_mxArray(&pStruct->kernelExecTimeoutEnabled, mxINT32_CLASS));
    mxSetField(mx, 0, "integrated", copy_scalar_to_mxArray(&pStruct->integrated, mxINT32_CLASS));
    mxSetField(mx, 0, "ECCEnabled", copy_scalar_to_mxArray(&pStruct->ECCEnabled, mxINT32_CLASS));
    mxSetField(mx, 0, "pciBusID", copy_scalar_to_mxArray(&pStruct->pciBusID, mxINT32_CLASS));
    mxSetField(mx, 0, "tccDriver", copy_scalar_to_mxArray(&pStruct->tccDriver, mxINT32_CLASS));
    return mx;
}



static void __cuGetDeviceProperties_api(mxArray **plhs, const mxArray ** prhs) {
    int32_T              dev;
    struct0_T            prop;
    int32_T             *errCode;
    boolean_T           *toplevel;

    /* Marshall in inputs and preallocate outputs */
    if (mxGetNumberOfElements(prhs[0]) && mxGetClassID(prhs[0]) != mxINT32_CLASS)
        mexErrMsgIdAndTxt("cuGetDeviceProperties:WrongInputType",
            "Input argument dev has incorrect data type; int32 is expected.");
    if (mxGetNumberOfElements(prhs[0]) != 1)
        mexErrMsgIdAndTxt("cuGetDeviceProperties:WrongSizeOfInputArg",
            "Argument dev should be a scalar.");
    dev = *(int32_T*)mxGetData(prhs[0]);
    prealloc_struct0_T(&prop);

    errCode = mxMalloc(sizeof(int32_T));

    toplevel = mxMalloc(sizeof(boolean_T));

    /* Invoke the target function */
    cuGetDeviceProperties(dev, &prop, errCode, toplevel);

    /* Deallocate input and marshall out function outputs */
    /* Nothing to be done for dev */
    plhs[0] = marshallout_struct0_T(&prop);
    plhs[1] = move_scalar_to_mxArray(errCode, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(toplevel, mxLOGICAL_CLASS);

}

static void __cuGetDeviceProperties_arg0_api(mxArray **plhs, const mxArray ** prhs) {
    struct0_T            prop;
    int32_T             *errCode;
    boolean_T           *toplevel;

    /* Marshall in inputs and preallocate outputs */
    prealloc_struct0_T(&prop);

    errCode = mxMalloc(sizeof(int32_T));

    toplevel = mxMalloc(sizeof(boolean_T));

    /* Invoke the target function */
    cuGetDeviceProperties_arg0(&prop, errCode, toplevel);

    /* Deallocate input and marshall out function outputs */
    plhs[0] = marshallout_struct0_T(&prop);
    plhs[1] = move_scalar_to_mxArray(errCode, mxINT32_CLASS);
    plhs[2] = move_scalar_to_mxArray(toplevel, mxLOGICAL_CLASS);

}


void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {
    /* Temporary copy for mex outputs. */
    mxArray *outputs[3];
    int i;
    int nOutputs = (nlhs < 1 ? 1 : nlhs);

    if (nrhs == 1) {
        if (nlhs > 3)
            mexErrMsgIdAndTxt("cuGetDeviceProperties:TooManyOutputArguments",
                "Too many output arguments for entry-point cuGetDeviceProperties.\n");
        /* Call the API function. */
        __cuGetDeviceProperties_api(outputs, prhs);
    }
    else if (nrhs == 0) {
        if (nlhs > 3)
            mexErrMsgIdAndTxt("cuGetDeviceProperties_arg0:TooManyOutputArguments",
                "Too many output arguments for entry-point cuGetDeviceProperties_arg0.\n");
        /* Call the API function. */
        __cuGetDeviceProperties_arg0_api(outputs, prhs);
    }
    else
        mexErrMsgIdAndTxt("cuGetDeviceProperties:WrongNumberOfInputs",
            "Incorrect number of input variables for entry-point cuGetDeviceProperties.");

    /* Copy over outputs to the caller. */
    for (i = 0; i < nOutputs; ++i) {
        plhs[i] = outputs[i];
    }
}
