function [vars, ret, nlhs, nrhs, structDefs, SDindex, pruned_args] = ...
    parse_cgfiles(funcname, altfunc, prototype, inports, outports, cpath, structDefs)
% Parse C files generated by codegen with the lib option

% TODO: Implement support for varargin, varargout, cell arrays, complex
%       numbers, global variables, and function pointers.

hfile = [cpath funcname '.h'];
tyfile = [cpath funcname '_types.h'];

if ~exist(hfile, 'file') ||  ~exist(tyfile, 'file')
    error('m2c:parse_cgfile', 'Could not locate header file %s.\n', hfile);
end

%% Read in C declarations
[fid, msg] = fopen(hfile, 'r', 'n', 'US-ASCII');
if fid<0; error('m2c:OpenFileFiled', '%s', msg); end

hfile = fread(fid, inf, '*char')';
hfile = regexprep(hfile, '\r\n', '\n');
hfile = regexprep(hfile, '\n', ' ');
fclose(fid);

% Extract function definition from the header file
toks = regexp(hfile, ['\sextern\s+(unsigned\s+)?(\w+)\s+' altfunc '\s*\(([^)]*)\)'], 'tokens');
cdecl.rettype = map_basetype(toks{1}{1}, toks{1}{2});
cdecl.args = toks{1}{3};

%% Read in type declarations
[fid, msg] = fopen(tyfile , 'r', 'n', 'US-ASCII');
if fid<0; error('m2c:OpenFileFiled', '%s', msg); end

% Read file into memory
typedecl = fread(fid, inf, '*char')';
typedecl = regexprep(typedecl, '\r\n', '\n');
fclose(fid);

%% Parse variable declarations
if ~isempty(cdecl.args)
    carglist = textscan(cdecl.args, '%s', 'delimiter', ',');
    carglist = carglist{1};
    if strcmp(carglist, 'void'); carglist = ''; end
else
    carglist = '';
end

[vars, structDefs, SDindex] = parse_var_decl(carglist, ...
    typedecl, hfile, prototype, inports, outports, structDefs, '', '');

[vars, ret, nlhs, nrhs, pruned_args] = sort_arguments(vars, cdecl.rettype, ...
    typedecl, hfile, prototype, inports, outports);

end

function [vars, structDefs, SDindex] = parse_var_decl(carglist, typedecl, ...
    hfile, prototype, inports, outports, structDefs, mprefix, cprefix)
% Parse declaration of variables

SDindex = [];

% Determine the number of input and output arguments
ncarg = length(carglist);

% Try to parse the cdecl
vars = repmat(struct('cname', '', 'mname', '', ...
    'type', '', 'basetype', '', 'structname', '', ...
    'modifier', '', 'isconst', false, 'iscomplex', true, 'subfields', [], ...
    'isemx', false, 'size', [], 'vardim', [], 'sizefield', [], ...
    'iindex', [], 'oindex', []), ncarg,1);

for i=1:ncarg
    toks = regexp(carglist{i}, '^(const\s+)?((unsigned|signed)\s+)?(\w+)\s*(\*\s*)*(\w+)\s*(\[\s*\d*\s*\])*$', 'tokens');

    % Set variable name
    assert(~isempty(toks{1}{5}));
    vars(i).cname = toks{1}{5};

    % Set isconst
    if ~isempty(toks{1}{1})
        assert(isequal(deblank(toks{1}{1}),'const'));
        vars(i).isconst = true;
    end

    % Set type and base type
    assert(~isempty(toks{1}{3}));
    vars(i).type = map_basetype(strtrim(toks{1}{2}), toks{1}{3});
    vars(i).modifier = strtrim(toks{1}{4});
    determine_subfields = false;

    % Obtain size information
    if ~isempty(prototype) && isprop(prototype.Arguments(i).Type, 'BaseType') && ...
            length(prototype.Arguments(i).Type.BaseType.Identifier)>9 && ...
            strcmp(prototype.Arguments(i).Type.BaseType.Identifier(end-8:end), 'StackData')
        determine_subfields = true;
        SDindex = i;
        size_info = prototype.Arguments(i);
    elseif i-(~isempty(SDindex))<= length(inports)
        size_info = inports(i-(~isempty(SDindex)));
        assert(isempty(mprefix) && (strcmp(size_info.GraphicalName, vars(i).cname) || ...
            strcmp(size_info.GraphicalName, vars(i).cname(3:end))) || ...
            ~isempty(mprefix) && strcmp(size_info.Identifier, vars(i).cname));
    else
        size_info = [];
        for j = 1 : length(outports)
            if strcmp(outports(j).GraphicalName, vars(i).cname)
                size_info = outports(j);
                break
            end
        end
        if isempty(size_info)
            for j = 1 : length(outports)
                if strcmp(outports(j).GraphicalName, vars(i).cname(3:end)) || ...
                        strcmp([outports(j).GraphicalName '_data'], vars(i).cname) || ...
                        strcmp([outports(j).GraphicalName '_size'], vars(i).cname)
                    size_info = outports(j);
                    break
                end
            end
            assert(~isempty(size_info));
        end
    end

    if strncmp(vars(i).type, 'emxArray_', 9)
        vars(i).isemx = true;

        if contains(basetypes, [' ' vars(i).type(10:end) ' '])
            vars(i).basetype = vars(i).type(10:end);
        else
            [~,b] = regexp(vars(i).type, ['emxArray_(' basetypes('regexp') ')_'], ...
                'match', 'tokens', 'once');

            if ~isempty(b)
                vars(i).basetype = b{1};
                vars(i).structname = b{1};
            else
                vars(i).basetype = 'struct';
                vars(i).structname = size_info.Type.BaseType.Identifier;

                if ~isfield(structDefs, vars(i).type)
                    [decl, sublist] = regexp(typedecl, ['\stypedef\s+struct\s+\w*\s*\{([^}][^\n]+\n)+\}\s+' ...
                        vars(i).structname '\s*;'], 'match', 'tokens');

                    if isempty(sublist)
                        error('Does not recognize datatype %s', vars(i).type);
                    elseif ~isempty(strfind(sublist{1}{1}, '{'))
                        error(['Nested structures is not supported for type %s. ' ...
                            'Its class definition generated by codegen is %s. ' ...
                            'You probably have a very large stack variable.'], ...
                            vars(i).type, decl{1});
                    end
                    sublist = textscan(sublist{1}{1}, '%s', 'delimiter', ';');

                    determine_subfields = true;
                else
                    vars(i).subfields = structDefs.(vars(i).type).fields;
                end
            end
        end

        [vars(i).size, vars(i).vardim, vars(i).mname, vars(i).iscomplex] = ...
            determine_type_size(size_info, mprefix, vars(i).cname, 0);

    else
        if ~contains(basetypes, [' ' vars(i).type ' '])
            vars(i).basetype = 'struct';
            vars(i).structname = vars(i).type;

            if isequal(cprefix, '.')
                % Do not recurse for StackData
            else
                if ~isfield(structDefs, vars(i).type)
                    [def, sublist0] = regexp(typedecl, ['\stypedef\s+struct(\s+\w+)?(\s*\{([^}][^\n]+\n)+\})?\s+' ...
                        vars(i).type '\s*;'], 'match', 'tokens');
                    if ~isempty(sublist0) && isempty(sublist0{1}{2})
                        [~, sublist] = regexp(typedecl, ['\s+struct\s+' strtrim(sublist0{1}{1}) ...
                            '\s*\{([^}][^\n]+\n)+\}\s*;'], 'match', 'tokens');
                    elseif ~isempty(sublist0) && ~isempty(sublist0{1}{2})
                        [~, sublist] = regexp(def{1}, '\{([^}][^\n]+\n)+\}', 'match', 'tokens');
                    elseif isempty(sublist0)
                        error('Cannot recognize datatype %s', vars(i).type);
                    end
                    sublist = textscan(sublist{1}{1}, '%s', 'delimiter', ';');

                    determine_subfields = true;
                else
                    vars(i).subfields = structDefs.(vars(i).type).fields;
                end
            end
        else
            vars(i).basetype = vars(i).type;
        end
    end

    % Set modifier and size
    if ~isempty(toks{1}{6})
        toks = regexp(toks{1}{6}, '\[\s*(\d*)\s*\]\s*', 'tokens');
        if isempty(toks{1}{1})
            totallen = 0;
        else
            totallen = str2double(toks{1}{1});
        end

        [vars(i).size, vars(i).vardim, vars(i).mname, vars(i).iscomplex] = ...
            determine_type_size(size_info, mprefix, vars(i).cname, totallen);
        vars(i).modifier = '*';

        if isempty(vars(i).size)
            if strcmp(vars(i).cname(1:end-4), vars(i-1).cname(1:end-4)) && ...
                    strcmp(vars(i).cname(end-4:end), '_size') && ...
                    strcmp(vars(i-1).cname(end-4:end), '_data')
                % This is a size field of the previous argument
                vars(i-1).sizefield = i;
                vars(i-1).isemx = 1;
                vars(i).size = totallen;
                vars(i).vardim = false;
                vars(i).mname = vars(i-1).mname;
            else
                error('Could not determine the size of C argument %s\n', vars(i).cname);
            end
        end
    elseif ~isequal(vars(i).modifier,'*') && isempty(mprefix) && ...
            contains(basetypes, [' ' vars(i).type ' '])
        vars(i).isconst = true;
    end

    % Set size for scalar or an optimized-out array
    if isempty(vars(i).size)
        [vars(i).size, vars(i).vardim, vars(i).mname, vars(i).iscomplex] = ...
            determine_type_size(size_info, mprefix, vars(i).cname, 0);
        if prod(vars(i).size)>1
            % This is an optimized-out array
            assert(strcmp(vars(i).cname, vars(i).mname) || ...
                strcmp(vars(i).cname, [vars(i).mname '_data']));
            vars(i).isemx = true;
            vars(i).sizefield = 'NULL';
        end
    end

    if determine_subfields
        % Parse type declaration
        if isprop(size_info.Type, 'BaseType')
            Elems = size_info.Type.BaseType.Elements;
        else
            Elems = size_info.Type.Elements;
        end

        % Use a special prefix to indicate StackData
        if isequal(SDindex, i)
            prefix = '.';
        else
            prefix = [cprefix vars(i).cname '.'];
        end
        [vars(i).subfields, structDefs] = parse_var_decl(sublist{1}, ...
            typedecl, hfile, [], Elems, [], ...
            structDefs, [mprefix vars(i).mname '.'], prefix);

        structDefs.(vars(i).type) = struct('fields', vars(i).subfields, ...
            'structname', vars(i).structname, ...
            'marshallinFunc', '', 'marshallinArrayFunc', '', ...
            'marshallinConstFunc', '', 'marshallinConstArrayFunc', '', ...
            'preallocFunc', '', 'preallocArrayFunc', '', ...
            'marshalloutFunc', '', 'marshalloutArrayFunc', '', ...
            'destroyFunc', '', 'destroyArrayFunc', '');
    end
end

end

function [vars, ret, nlhs, nrhs, pruned_args] = sort_arguments(vars, rettype, ...
    typedecl, hfile, prototype, inports, outports)
% Determine the order of the arguments in MATLAB

nlhs = length(outports);
nrhs = length(inports);

for i=1:nrhs
    found = false;
    mname = inports(i).GraphicalName;
    % Parse input arguments
    for k=i:length(vars)
        if isequal(vars(k).mname, mname)
            vars(k).iindex = i;
            found = true;
            break;
        end
    end

    if ~found
        for k=i:length(vars)
            if isempty(vars(k).iindex) && ~isempty(regexp(vars(k).cname, ...
                    ['^\w+_' mname '$'],'once'))
                    assert(isequal(vars(k).mname, mname));
                    vars(k).iindex = i;
                found = true;
                break;
            end
        end
    end

    if ~found
        if i==nrhs && isequal(mname, 'varargin')
            nrhs = nrhs-1;
        end
    end
end

ret = [];
has_pruned = false;
for i=1:nlhs
    mname = outports(i).GraphicalName;

    % Parse output arguments
    if (i==nlhs && isequal(mname, 'varargout'))
        nlhs = nlhs - 1;
    elseif isempty(outports(i).Implementation)
        has_pruned = true;
    else
        found = false;
        for k=1:length(vars)
            if isequal(vars(k).mname, mname)
                assert(isequal(vars(k).mname, mname));
                vars(k).oindex = i;
                found = true;
                break;
            end
        end

        if found
            continue;
        end

        assert(isempty(ret) && ~isequal(rettype, 'void'), 'Incorrect return variable');
        ret = struct('cname', ['_' mname], 'mname', mname, ...
            'type', rettype, 'basetype', rettype, 'structname', '', ...
            'modifier', '', 'isconst', false, 'iscomplex', false, 'subfields', [], ...
            'isemx', false, 'size', 1, 'vardim', 0, 'sizefield', [], ...
            'iindex', [], 'oindex', i);
        % Check return type
        if ~contains(basetypes, [' ' rettype ' '])
            ret.basetype = 'struct';
            [~, sublist] = regexp(typedecl, ['\stypedef\s+struct\s+\w*\s*\{([^}]+)\}\s+' ...
                ret.type '\s*;'], 'match', 'tokens');
            if isempty(sublist)
                error('Cannot recognize datatype %s', rettype);
            end
            sublist = textscan(sublist{1}{1}, '%s', 'delimiter', ';');

            % Parse type declaration
            [ret.subfields, structDefs] = parse_var_decl(sublist{1}, ...
                typedecl, hfile, prototype, inports, outports, structDefs, [ret.mname '.'], '');
        end
    end
end


if nargout>4
    % Determine the pruned arguments
    pruned_args = repmat(struct('cname', '', 'mname', '', ...
        'type', '', 'iscomplex', false, 'size', [], 'oindex', []), 1,0);

    if has_pruned
        npruned = 0;
        % Loop through all the output arguments and check whether any was pruned
        for i=1:length(outports)
            if isempty(outports(i).Implementation)
                % check to see whether the variable is in vars
                mname = outports(i).GraphicalName;
                pruned_args = [pruned_args, struct('cname', '', 'mname', mname, ...
                    'type', '', 'iscomplex', false, 'size', [], 'oindex', i)]; %#ok<AGROW>
                npruned = npruned + 1;
                [pruned_args(npruned).size, ~, ~, ...
                    pruned_args(npruned).iscomplex, pruned_args(npruned).type] = ...
                    determine_type_size(outports(i).Type, '', mname, 0);
            end
        end
    end
end

end

function [sz, vardim, mname, iscomplex, basetype] = ...
    determine_type_size(size_info, mprefix, cname, totalsize)
% Parse the prototype to determine the size of a variable

if strncmp([mprefix cname], 'varargin', 8)
    error('m2c:vararginUnsupported', ...
        ['M2C cannot determine input data type for varargin for top-level functions. ' ...
        'Please write a wrapper function to name ' ...
        'the optional argument "varargin" expliclty.']);
end

if isprop(size_info.Type, 'BaseType')
    % This is a varible-sized array
    basetype = size_info.Type.BaseType.Identifier;

    if isprop(size_info.Type, 'Dimensions')
        sz = size_info.Type.Dimensions;
        vardim = ~isfinite(sz);

        % Trim high-dimensional arrays
        for j=length(sz):-1:1
            if j==1 || sz(j) ~= 1 || vardim(j)
                sz(j+1:end) = [];
                vardim(j+1:end) = [];
                break;
            end
        end
    else
        % This is for StackData
        assert(contains(size_info.Type.BaseType.Identifier, 'StackData') || ...
            contains(size_info.Type.BaseType.Identifier, 'PersistentData'));
        sz = 1;
        vardim = false;
    end
else
    % This is a fixed-size array (including scalar or struct)
    if isprop(size_info.Type, 'Identifier')
        basetype = size_info.Type.Identifier;
    else
        basetype = size_info.BaseType.Identifier;
    end
    assert(~isprop(size_info, 'Dimensions') && ~isprop(size_info.Type, 'Dimensions'));

    sz = 1;
    vardim = false;
end

assert(totalsize==0 || totalsize == prod(sz), 'Size handling error.');

try
    mname = size_info.GraphicalName;
catch
    mname = cname;
end
iscomplex = isstruct(size_info) && ~strcmp(size_info.Type.ClassName, 'struct') ...
    && size_info.Type.Complex || ~isstruct(size_info) && ~isempty(sz) && ~isreal(size_info);

end

function str = basetypes(~)
% Obtain list of base datatypes
if nargin==0
    str = [' boolean_T char_T real_T real_T real64_T real32_T ' ...
        'int32_T uint32_T int8_T uint8_T int16_T uint16_T int64_T uint64_T '];
else
    str = ['(boolean_T|char_T|real_T|real64_T|real32_T|' ...
        'int32_T|uint32_T|int8_T|uint8_T|int16_T|uint16_T|int64_T|uint64_T)'];
end
end

function str = map_basetype(sign, type)

switch type
    case 'char'
        if isempty(sign)
            str = 'char_T';
        elseif isequal(sign, 'signed')
            str = 'int8_T';
        elseif isequal(sign, 'unsigned')
            str = 'uint8_T';
        end
    case 'short'
        if isempty(sign) || isequal(sign, 'signed')
            str = 'int16_T';
        elseif isequal(sign, 'unsigned')
            str = 'uint16_T';
        end
    case 'int'
        if isempty(sign) || isequal(sign, 'signed')
            str = 'int32_T';
        elseif isequal(sign, 'unsigned')
            str = 'uint32_T';
        end
    case 'long'
        if isempty(sign) || isequal(sign, 'signed')
            str = 'int64_T';
        elseif isequal(sign, 'unsigned')
            str = 'uint64_T';
        end
    case 'float'
        str = 'real32_T';
    case 'double'
        str = 'real64_T';
    otherwise
        str = type;
end
end
