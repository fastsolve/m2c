function [vars, ret, nlhs, nrhs, structDefs, SDindex, pruned_args] = ...
    parse_cgfiles(funcname, altfunc, mpath, cpath, structDefs)
% Parse C files generated by codegen with the lib option

% TODO: Implement support for varargin, varargout, cell arrays, complex
%       numbers, global variables, and function pointers.

% Check existence of the files
mfile = [mpath altfunc '.m'];
if ~exist(mfile, 'file') && exist([mpath 'codegen/' altfunc '.m'], 'file')
    mfile = [mpath 'codegen/' altfunc '.m'];
end

hfile = [cpath funcname '.h'];
tyfile = [cpath funcname '_types.h'];
htmlfile = get_htmlfile(cpath, altfunc);

if isempty(mfile)
    error('m2c:parse_cgfile', 'Cannot find MATLAB file %s', funcname);
end

if ~exist(hfile, 'file') ||  ~exist(tyfile, 'file')
    error('m2c:parse_cgfile', 'Could not locate header file %s.\n', hfile);
elseif ~exist(htmlfile, 'file')
    error('m2c:parse_cgfile', ['Cannot locate codegen report for function %s. ' ...
        'Probably function name was misspelled in the M file.'], ...
        funcname);
end

%% Read in M-file
m_args = extractMfileArgs(mfile);

%% Read in C declarations
[fid, msg] = fopen(hfile, 'r', 'n', 'US-ASCII');
if fid<0; error('m2c:OpenFileFiled', '%s', msg); end

hfile = fread(fid, inf, '*char')';
hfile = regexprep(hfile, '\r\n', '\n');
hfile = regexprep(hfile, '\n', ' ');
fclose(fid);

% Extract function definition from the header file
toks = regexp(hfile, ['\sextern\s+(unsigned\s+)?(\w+)\s+' altfunc '\s*\(([^)]*)\)'], 'tokens');
cdecl.rettype = map_basetype(toks{1}{1}, toks{1}{2});
cdecl.args = toks{1}{3};

%% Read in type declarations
[fid, msg] = fopen(tyfile , 'r', 'n', 'US-ASCII');
if fid<0; error('m2c:OpenFileFiled', '%s', msg); end

% Read file into memory
typedecl = fread(fid, inf, '*char')';
typedecl = regexprep(typedecl, '\r\n', '\n');
fclose(fid);

%% Read HTML file for further processing
[fid, msg] = fopen(htmlfile, 'r', 'n', 'US-ASCII');
if fid<0; error('m2c:OpenFileFiled', '%s', msg); end

% Read file into memory
htmlfile = fread(fid, inf, '*char')';
htmlfile = regexprep(htmlfile, '<[^>]+>', ' ');
htmlfile = strrep(htmlfile, '&nbsp;', '');

%htmlfile = textscan(fid, '%s', 'CommentStyle', {'<','>'}, 'Delimiter', '(<>)');
fclose(fid);

%% Parse variable declarations
if ~isempty(cdecl.args)
    carglist = textscan(cdecl.args, '%s', 'delimiter', ',');
    carglist = carglist{1};
    if strcmp(carglist, 'void'); carglist = ''; end
else
    carglist = '';
end

[vars, structDefs, SDindex] = parse_var_decl(carglist, ...
    typedecl, hfile, htmlfile, structDefs, '', '');

[vars, ret, nlhs, nrhs, pruned_args] = sort_arguments(vars, cdecl.rettype, ...
    m_args, typedecl, hfile, htmlfile);

end

function [vars, structDefs, SDindex] = parse_var_decl(carglist, typedecl, ...
    hfile, htmlfile, structDefs, mprefix, cprefix)
% Parse declaration of variables

SDindex = [];

% Determine the number of input and output arguments
ncarg = length(carglist);

% Try to parse the cdecl
vars = repmat(struct('cname', '', 'mname', '', ...
    'type', '', 'basetype', '', 'structname', '', ...
    'modifier', '', 'isconst', false, 'iscomplex', true, 'subfields', [], ...
    'isemx', false, 'size', [], 'vardim', [], 'sizefield', [], ...
    'iindex', [], 'oindex', []), ncarg,1);

for i=1:ncarg
    toks = regexp(carglist{i}, '^(const\s+)?((unsigned|signed)\s+)?(\w+)\s*(\*\s*)*(\w+)\s*(\[\s*\d*\s*\])*$', 'tokens');

    % Set variable name
    assert(~isempty(toks{1}{5}));
    vars(i).cname = toks{1}{5};

    % Set isconst
    if ~isempty(toks{1}{1})
        assert(isequal(deblank(toks{1}{1}),'const'));
        vars(i).isconst = true;
    end

    % Set type and base type
    assert(~isempty(toks{1}{3}));
    vars(i).type = map_basetype(strtrim(toks{1}{2}), toks{1}{3});

    determine_subfields = false;

    if strncmp(vars(i).type, 'emxArray_', 9) && ...
            contains(basetypes, [' ' vars(i).type(10:end) ' '])
        vars(i).basetype = vars(i).type(10:end);
        vars(i).isemx = true;
        [vars(i).size, vars(i).vardim, vars(i).mname, vars(i).iscomplex] = ...
            determine_type_size(htmlfile, mprefix, vars(i).cname, 0);

        vars(i).modifier = strtrim(toks{1}{4});
    elseif strncmp(vars(i).type, 'emxArray_', 9) % struct array
        vars(i).isemx = true;

        % Determine basetype
        [~,b] = regexp(typedecl, ['\sstruct\s+' vars(i).type ...
            '\s*\{\s*(\w+)\s*\*data;\s'], 'match', 'tokens');
        if isempty(b)
            [~,b] = regexp(vars(i).type, ['emxArray_(' basetypes('regexp') ')_'], ...
                'match', 'tokens', 'once');
            if isempty(b)
                % This is a static sized array.
                [~,b] = regexp(typedecl, ['\sstruct\s+' vars(i).type ...
                    '\s*\{\s*(\w+)\s*data\[\d+\];\s'], 'match', 'tokens', 'once');
            end
            vars(i).basetype = b{1};
            vars(i).structname = b{1};
            [vars(i).size, vars(i).vardim, vars(i).mname, vars(i).iscomplex] = ...
                determine_type_size(htmlfile, mprefix, vars(i).cname, 0);
        else
            vars(i).basetype = 'struct';
            vars(i).structname = b{1}{1};

            [vars(i).size, vars(i).vardim, vars(i).mname, vars(i).iscomplex] = ...
                determine_type_size(htmlfile, mprefix, vars(i).cname, 0);

            if ~isfield(structDefs, vars(i).type)
                [decl, sublist] = regexp(typedecl, ['\stypedef\s+struct\s+\w*\s*\{([^}][^\n]+\n)+\}\s+' ...
                    vars(i).structname '\s*;'], 'match', 'tokens');

                if isempty(sublist)
                    error('Does not recognize datatype %s', vars(i).type);
                elseif ~isempty(strfind(sublist{1}{1}, '{'))
                    error(['Nested structures is not supported for type %s. ' ...
                        'Its class definition generated by codegen is %s. ' ...
                        'You probably have a very large stack variable.'], ...
                        vars(i).type, decl{1});
                end
                sublist = textscan(sublist{1}{1}, '%s', 'delimiter', ';');

                determine_subfields = true;
            else
                vars(i).subfields = structDefs.(vars(i).type).fields;
            end
        end
    else
        if ~contains(basetypes, [' ' vars(i).type ' '])
            vars(i).basetype = 'struct';
            vars(i).structname = vars(i).type;

            if ~isempty(cprefix) && ~isempty(regexp(cprefix, 'SD.$', 'once')) && ncarg==1
                SDindex = 1;
            elseif ~isfield(structDefs, vars(i).type)
                [def, sublist0] = regexp(typedecl, ['\stypedef\s+struct(\s+\w+)?(\s*\{([^}][^\n]+\n)+\})?\s+' ...
                    vars(i).type '\s*;'], 'match', 'tokens');
                if ~isempty(sublist0) && isempty(sublist0{1}{2})
                    [~, sublist] = regexp(typedecl, ['\s+struct\s+' strtrim(sublist0{1}{1}) ...
                        '\s*\{([^}][^\n]+\n)+\}\s*;'], 'match', 'tokens');
                elseif ~isempty(sublist0) && ~isempty(sublist0{1}{2})
                    [~, sublist] = regexp(def{1}, '\{([^}][^\n]+\n)+\}', 'match', 'tokens');
                elseif isempty(sublist0)
                    error('Cannot recognize datatype %s', vars(i).type);
                end
                sublist = textscan(sublist{1}{1}, '%s', 'delimiter', ';');

                determine_subfields = true;
            else
                vars(i).subfields = structDefs.(vars(i).type).fields;
            end
        else
            vars(i).basetype = vars(i).type;
        end

        vars(i).modifier = strtrim(toks{1}{4});
    end

    % Set modifier and size
    if ~isempty(toks{1}{6})
        toks = regexp(toks{1}{6}, '\[\s*(\d*)\s*\]\s*', 'tokens');
        if isempty(toks{1}{1})
            totallen = 0;
        else
            totallen = str2double(toks{1}{1});
        end

        [vars(i).size, vars(i).vardim, vars(i).mname, vars(i).iscomplex] = ...
            determine_type_size(htmlfile, mprefix, vars(i).cname, totallen);
        vars(i).modifier = '*';

        if isempty(vars(i).size)
            if isequal(vars(i).cname(1:end-4), vars(i-1).cname(1:end-4)) && ...
                    isequal(vars(i).cname(end-3:end), 'size') && ...
                    isequal(vars(i-1).cname(end-3:end), 'data')
                % This is a size field of the previous argument
                vars(i-1).sizefield = i;
                vars(i-1).isemx = 1;
                vars(i).size = totallen;
                vars(i).vardim = false;
                vars(i).mname = vars(i-1).mname;
            else
                error('Could not determine the size of C argument %s\n', vars(i).cname);
            end
        end
    elseif ~isequal(vars(i).modifier,'*') && isempty(mprefix) && ...
            contains(basetypes, [' ' vars(i).type ' '])
        vars(i).isconst = true;
    end

    % Set size for scalar or an optimized-out array
    if isempty(vars(i).size)
        [vars(i).size, vars(i).vardim, vars(i).mname, vars(i).iscomplex] = ...
            determine_type_size(htmlfile, mprefix, vars(i).cname, 0);
        if prod(vars(i).size)>1
            % This is an optimized
            assert(isequal(vars(i).cname, [vars(i).mname '_data']));
            vars(i).isemx = true;
            vars(i).sizefield = 'NULL';
        end
    end

    if determine_subfields
        % Parse type declaration
        [vars(i).subfields, structDefs, SDindex] = parse_var_decl(sublist{1}, ...
            typedecl, hfile, htmlfile, structDefs, [mprefix vars(i).mname '.'], [cprefix vars(i).cname '.']);
        if ~isempty(SDindex); SDindex=i; end

        structDefs.(vars(i).type) = struct('fields', vars(i).subfields, ...
            'structname', vars(i).structname, ...
            'marshallinFunc', '', 'marshallinArrayFunc', '', ...
            'marshallinConstFunc', '', 'marshallinConstArrayFunc', '', ...
            'preallocFunc', '', 'preallocArrayFunc', '', ...
            'marshalloutFunc', '', 'marshalloutArrayFunc', '', ...
            'destroyFunc', '', 'destroyArrayFunc', '');
    end
end

end

function [vars, ret, nlhs, nrhs, pruned_args] = sort_arguments(vars, rettype, m_args, ...
    typedecl, hfile, htmlfile, pruned_args)
% Determine the order of the arguments in MATLAB

nlhs = length(m_args.output);
nrhs = length(m_args.input);

for i=1:nrhs
    found = false;
    % Parse input arguments
    for k=i:length(vars)
        if isequal(vars(k).mname,m_args.input{i})
            vars(k).iindex = i;
            found = true;
            break;
        end
    end

    if ~found
        for k=i:length(vars)
            if isempty(vars(k).iindex) && ~isempty(regexp(vars(k).cname, ...
                    ['^\w+_' m_args.input{i} '$'],'once'))
                assert(isequal(vars(k).mname, m_args.input{i}));
                vars(k).iindex = i;
                found = true;
                break;
            end
        end
    end

    if ~found
        if i==nrhs && isequal(m_args.input{i}, 'varargin')
            nrhs = nrhs-1;
        end
    end
end

ret = [];
for i=1:nlhs
    % Parse output arguments
    found = false;
    for k=1:length(vars)
        if isequal(vars(k).mname, m_args.output{i})
            assert(isequal(vars(k).mname, m_args.output{i}));
            vars(k).oindex = i;
            found = true;
            break;
        end
    end

    if found
        continue;
    elseif (i==nlhs && isequal(m_args.output{i}, 'varargout'))
        nlhs = nlhs - 1;
    elseif isequal(rettype, 'void')
        % Parse output arguments
        len = length(m_args.output{i});
        for k=1:length(vars)
            if isequal(vars(k).mname, m_args.output{i}) || ...
                    ~isempty(strfind(vars(k).cname, m_args.output{i})) && ...
                    isempty(vars(k).oindex) && ...
                    isequal(vars(k).cname(end-len+1:end), m_args.output{i})
                assert(isequal(vars(k).mname, m_args.output{i}));
                vars(k).oindex = i;
                break;
            end
        end
    else
        assert(isempty(ret) && ~isequal(rettype, 'void'), 'Incorrect return variable');
        ret = struct('cname', ['_' m_args.output{i}], 'mname', m_args.output{i}, ...
            'type', rettype, 'basetype', rettype, 'structname', '', ...
            'modifier', '', 'isconst', false, 'iscomplex', false, 'subfields', [], ...
            'isemx', false, 'size', 1, 'vardim', 0, 'sizefield', [], ...
            'iindex', [], 'oindex', i);
        % Check return type
        if ~contains(basetypes, [' ' rettype ' '])
            ret.basetype = 'struct';
            [~, sublist] = regexp(typedecl, ['\stypedef\s+struct\s+\w*\s*\{([^}]+)\}\s+' ...
                ret.type '\s*;'], 'match', 'tokens');
            if isempty(sublist)
                error('Cannot recognize datatype %s', rettype);
            end
            sublist = textscan(sublist{1}{1}, '%s', 'delimiter', ';');

            % Parse type declaration
            [ret.subfields, structDefs] = parse_var_decl(sublist{1}, ...
                typedecl, hfile, htmlfile, structDefs, [ret.mname '.'], '');
        end
    end
end

if nargout>4
    % Determine the pruned arguments
    pruned_args = repmat(struct('cname', '', 'mname', '', ...
        'type', '', 'iscomplex', false, 'size', [], 'oindex', []), 1,0);

    vars_ret = [vars; ret];
    npruned = 0;
    % Loop through all the output arguments and check whether any was pruned
    for i=1:length(m_args.output)
        % check to see whether the variable is in vars
        name = m_args.output{i};
        found = 0;
        for j=1:length(vars_ret)
            if isequal(vars_ret(j).mname, name)
                found = j;
                break;
            end
        end
        if ~found
            pruned_args = [pruned_args, struct('cname', '', 'mname', name, ...
                'type', '', 'iscomplex', false, 'size', [], 'oindex', i)]; %#ok<AGROW>
            npruned = npruned + 1;
            [pruned_args(npruned).size, ~, ~, ...
                pruned_args(npruned).iscomplex, pruned_args(npruned).type] = ...
                determine_type_size(htmlfile, '', name, 0);
        end
    end
end

end

function [sz, vardim, mname, iscomplex, basetype] = ...
    determine_type_size(htmlfile, mprefix, cname, totalsize)
% Parse the HTML file to determine the size of a variable

varname = [mprefix cname];

% Determine the size of the variable
if ~contains(varname,'.')
    type = 'I\/O|Input|Output';
else
    type = 'Field';
end

re_vardef = ['\s+(?:&gt;\s+\d+)?\s+(?:' type ')\s+ ([\dx\s:?\*]+)(\w+|-)\s+(\w+|-)'];

iscomplex = false;
toks = regexp(htmlfile, ['\s+' varname re_vardef], 'tokens');
if isempty(toks)
    if strncmp(varname, 'varargin', 8)
        error('m2c:vararginUnsupported', ...
            ['M2C cannot determine input data type for varargin for top-level functions. ' ...
            'Please write a wrapper function to name ' ...
            'the optional argument "varargin" expliclty.']);
    elseif ~isempty(regexp(varname, '\w+_data', 'once'))
        toks = regexp(htmlfile, ['\s+' varname(1:end-5) re_vardef], 'tokens');
        mname = cname(1:end-5);
    elseif ~isempty(regexp(cname, '[a-z]_', 'once'))
        toks = regexp(htmlfile, ['\s+' [mprefix cname(3:end)] re_vardef], 'tokens');
        mname = cname(3:end);
    else
        mname = '';
        vardim = 0;
        basetype = '';
        sz = 1;
        return;
    end
else
    mname = cname;
end

if isempty(toks)
    sz = [];
    vardim = [];
    basetype = '';
else
    szlist = textscan(toks{1}{1}, '%s', 'delimiter', 'x*');
    sz = zeros(length(szlist{1}),1);
    vardim = false(length(szlist{1}),1);

    for j=1:length(sz)
        if szlist{1}{j}(1) == ':'
            vardim(j) = true;
            if ~isempty(regexp(szlist{1}{j}, ':\s*\d+', 'once'))
                sz(j) = str2double(szlist{1}{j}(2:end));
            else
                sz(j) = inf;
            end
        else
            vardim(j) = false;
            sz(j) = str2double(szlist{1}{j});
        end
    end

    basetype = toks{1}{2};
    iscomplex = isequal(toks{1}{3}, 'Yes');

    % Trim high-dimensional arrays
    for j=length(sz):-1:1
        if j==1 || sz(j) ~= 1 || vardim(j)
            sz(j+1:end) = [];
            vardim(j+1:end) = [];
            break;
        end
    end

    assert(totalsize==0 || totalsize == prod(sz), 'Size handling error.');
end

end

function str = basetypes(~)
% Obtain list of base datatypes
if nargin==0
    str = [' boolean_T char_T real_T real_T real64_T real32_T ' ...
        'int32_T uint32_T int8_T uint8_T int16_T uint16_T int64_T uint64_T '];
else
    str = ['(boolean_T|char_T|real_T|real64_T|real32_T|' ...
        'int32_T|uint32_T|int8_T|uint8_T|int16_T|uint16_T|int64_T|uint64_T)'];
end
end

function str = map_basetype(sign, type)

switch type
    case 'char'
        if isempty(sign)
            str = 'char_T';
        elseif isequal(sign, 'signed')
            str = 'int8_T';
        elseif isequal(sign, 'unsigned')
            str = 'uint8_T';
        end
    case 'short'
        if isempty(sign) || isequal(sign, 'signed')
            str = 'int16_T';
        elseif isequal(sign, 'unsigned')
            str = 'uint16_T';
        end
    case 'int'
        if isempty(sign) || isequal(sign, 'signed')
            str = 'int32_T';
        elseif isequal(sign, 'unsigned')
            str = 'uint32_T';
        end
    case 'long'
        if isempty(sign) || isequal(sign, 'signed')
            str = 'int64_T';
        elseif isequal(sign, 'unsigned')
            str = 'uint64_T';
        end
    case 'float'
        str = 'real32_T';
    case 'double'
        str = 'real64_T';
    otherwise
        str = type;
end
end

function htmlfile = get_htmlfile(cpath, altfunc)
% Locate HTML file for the given function name and alternative name.

htmlfile = [cpath '/html/' altfunc '1_watch.html'];
if exist(htmlfile,'file')
    return;
end

listing = dir([cpath '/html/' altfunc '*_mcode.html']);
htmlfile = '';
for i=length(listing):-1:1
    if ~isempty(regexp(listing(i).name, [altfunc '\d+_mcode.html'],'once'))
        % Check corresponding _mcode file
        mcode_file = [cpath '/html/' listing(i).name];
        [fid, msg] = fopen(mcode_file, 'r', 'n', 'US-ASCII');
        if fid<0; error('m2c:OpenFileFiled', '%s', msg); end

        % Read file into memory
        mcode = fread(fid, inf, '*char')';
        fclose(fid);

        mcode = regexprep(mcode, '<[^>]+>', ' ');
        mcode = strrep(mcode, '&nbsp;', '');

        mheader = ['\s*function\s*(\[[\w\s,]+\]|\s+\w+)?\s*=?\s*' altfunc ...
            '\s*(\([\w\s,]*\))?'];

        if ~isempty(regexp(mcode, mheader, 'once'))
            htmlfile = [cpath '/html/' strrep(listing(i).name, '_mcode.html', '_watch.html')];
            return;
        end
    end
end
end
