function changed = post_codegen( filename, prog, enableopt)
% Modify function generated by codegen

str = read_file( filename);
if nargin<2; prog='m2c'; end

str0 = str;

% Remove declaration of emxEnsureCapacity
str = regexprep(str, 'static\s+void\s+emxEnsureCapacity\s*\([^,\)]+,[^,\)]+,[^,\)]+\);\n', '');
str = regexprep(str, ['(static\s+)?void\s+emxEnsureCapacity\s*\([^,\)]+,[^,\)]+,[^,\)]+\)\s*' funcbody ], '');

% Remove declaration of emxEnsureCapacity for structs
str = regexprep(str, 'void\s+emxEnsureCapacity_(\w+)\s*\([^,\)]+,[^,\)]+\);', ...
    'declare_emxEnsureCapacityStruct($1);');
str = regexprep(str, ['void\s+emxEnsureCapacity_(\w+)\s*\([^,\)]+,[^,\)]+\)\s*' funcbody], ...
    'define_emxEnsureCapacityStruct($1)');

basictype = '(boolean_T|char_T|int8_T|int16_T|int32_T|int64_T|uint8_T|uint16_T|uint32_T|uint64_T|real_T|real32_T|real64_T)';

% Remove declaration of emxInit_basictype and emxFree_basictype for 
% types declared in ctypefile
ks = strfind( filename, '.');
ctype_filename = [filename(1:ks(end)-1), '_types.h' filename(ks(end)+2:end)];
ctypes = read_file( ctype_filename);

tokens = regexp(ctypes, ['struct\s+emxArray_(' basictype ')'], 'tokens');
for i=1:length(tokens)
    str = regexprep(str, ['static\s+void\s+emxInit_' ...
        tokens{i}{1} '\([^,\)]+,[^,\)]+\);\n'], '');   
    str = regexprep(str, ['static\s+void\s+emxInit_' ...
        tokens{i}{1} '\([^,\)]+,[^,\)]+\)\s*' funcbody], '');   

    str = regexprep(str, ['static\s+void\s+emxFree_' ...
        tokens{i}{1} '\([^,\)]+\);\n'], '');
    str = regexprep(str, ['static\s+void\s+emxFree_' ...
        tokens{i}{1} '\([^,\)]+\)\s*' funcbody], '');   
end

% Remove declaration of emxInit_ for local basic types and structs
str = regexprep(str, ['void\s+(\w*)emxInit_(\w+)' ...
    '\(emxArray_(\w+)[^,\)]+,[^,\)]+\);'], 'define_emxInit($1emxInit_$2, $3)');
str = regexprep(str, ['(static\s+)?void\s+\w*emxInit_\w+' ...
    '\([^,\)]+,[^,\)]+\)\s*' funcbody], '');

% Remove declaration of emxFree_struct for local basic types and structs
tokens = regexp(str, 'void\s+\w*emxFree_\w+\(emxArray_(\w+)\s+[^,\)]+\);', 'tokens');
for i=1:length(tokens)
    if ~isempty(regexp(str, ['void\s+emxFreeStruct_' tokens{i}{1} '\s*('], 'once'))
        str = regexprep(str, ['void\s+(\w*)emxFree_(\w+)\s*\(emxArray_(' ...
            tokens{i}{1} ')\s+[^,\)]+\);'], ...
            'declare_emxFreeStruct($1emxFree_$2,$3);');
        str = regexprep(str, ['void\s+(\w*)emxFree_(\w+)\s*\(emxArray_(' ...
            tokens{i}{1} ')\s+[^,\)]+\)\s*' funcbody], ...
            'define_emxFreeStruct($1emxFree_$2, $3)');
    else
        str = regexprep(str, ['void\s+(\w*)emxFree_(\w+)\s*\(emxArray_(' ...
            tokens{i}{1} ')\s+[^,\)]+\);'], 'define_emxFree($1emxFree_$2, $3)');
        str = regexprep(str, ['(static\s+)?void\s+\w*emxFree_\w+\s*\(emxArray_' ...
            tokens{i}{1} '\s+[^,\)]+\)\s*' funcbody], '');
    end
end

% Remove declaration of emxCreate_basictype, emxCreateND_basictype, 
% and emxCreateWrapperND_basictype, emxDestroyArray_basictype
str = regexprep(str, ['emxArray_\w+\s+\*emxCreate_' basictype ...
    '\([^,\)]+,[^,\)]+\)\s*' funcbody], '');
str = regexprep(str, ['emxArray_\w+\s+\*emxCreateND_' basictype ...
    '\([^,\)]+,[^,\)]+\)\s*' funcbody], '');
str = regexprep(str, ['emxArray_\w+\s+\*emxCreateWrapper_' basictype ...
    '\([^,\)]+,[^,\)]+,[^,\)]+\)\s*' funcbody], '');
str = regexprep(str, ['emxArray_\w+\s+\*emxCreateWrapperND_' basictype ...
    '\([^,\)]+,[^,\)]+,[^,\)]+\)\s*' funcbody], '');
str = regexprep(str, ['void\s+emxDestroyArray_' basictype ...
    '\([^,\)]+\)\s*' funcbody], '');


% Remove declaration of emxCreate_struct, emxCreateND_struct, 
% and emxCreateWrapperND_struct, emxDestroyArray_struct
str = regexprep(str, ['emxArray_(\w+)\s+\*emxCreate_\w+\s*' ...
    '\([^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreate($2, $1)');
str = regexprep(str, ['emxArray_(\w+)\s+\*emxCreateND_\w+\s*' ...
    '\([^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreateND($2, $1)');
str = regexprep(str, ['emxArray_(\w+)\s+\*emxCreateWrapper_\w+\s*' ...
    '\(\s*(\w+)[^,\)]+,[^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreateWrapper($3, $1, $2)');
str = regexprep(str, ['emxArray_(\w+)\s+\*emxCreateWrapperND_\w+\s*' ...
    '\(\s*(\w+)[^,\)]+,[^,\)]+,[^,\)]+\)\s*{[^}]+\s+(\w*emxInit_\w+)\s*\([^\)]+\);(?:[^}][^\n]*\n)+}'], ...
    'define_emxCreateWrapperND($3, $1, $2)');
str = regexprep(str, ['void\s+emxDestroyArray_(\w+)\s*' ...
    '\([^,\)]+\)\s*{\s+(\w*emxFree_\w+)\s*\([^\)]+\);\s+}'], ...
    'define_emxDestroyArray($2, $1)');

% Remove definition of emxArray__common
str = regexprep(str, ['#ifndef\s+struct_emxArray__common\s+'...
    '#define\s+struct_emxArray__common\s+struct\s+emxArray__common\s+{[^}]+};\s+' ...
    '#endif\s+#ifndef\s+typedef_emxArray__common\s+#define\s+typedef_emxArray__common\s+' ...
    'typedef\s+struct\s+emxArray__common\s+emxArray__common;\s+#endif\n'], '');

% Omit declaration of variable references.
str = regexprep( str, '\n#ref\([^\)]+\);', '');

if exist('replace_pragmas', 'file')
    str = replace_pragmas(str);
end

% Remove two consecutive empty lines
while ~isempty( regexp( str, '\n\n\n', 'once'))
    str = regexprep( str, '(\n\n)\n', '$1');
end

if enableopt
    % Disable emxCopyStruct
    str = disable_emxCopyStruct( str, prog);
    
    % Check copying of constant input arrays
    check_inputArrays( str, prog);
    
    % Check allocation of local arrays
    check_localArrays( str, prog);
    
    % Check casting of integers
    check_intCasting( str, prog);
end

changed = ~isequal( str, str0);
if changed
    write_file( filename, str);
end
end

function str = disable_emxCopyStruct( str, prog)
% Disable emxCopyStruct

funcs = regexp( str, '(\w+)(\([^)]+\))\s*({([^}][^\n]*\n)+\s+(?:\w+_)?emxCopyStruct_\w+\(&\w+,\s*\w+\);([^}][^\n]*\n)+})', 'tokens');

for i=1:length(funcs)
    % Remove emxCopyStruct_ from the function.
    funname = funcs{i}{1};
    args = funcs{i}{2};
    fun = funcs{i}{3};
    
    if ~isempty(strfind( funname, 'emlrt_')); continue; end
    toks = regexp( fun, '\s+(?:\w+_)?emxCopyStruct_(\w+)\(&(\w+),\s*(\w+)\);', 'tokens');
    
    for j=1:length(toks)
        assert( isequal([ '_' toks{j}{3}], toks{j}{2}(end-length(toks{j}{3}):end)));
        
        % Check input arguments to see whether the object is defined as const
        if ~isempty( regexp( args, ['\sconst\s+' toks{j}{1} '\w*\s*\*?\s*' toks{j}{3}], 'once'))
            warning( [prog ':StructCopyConst'], ['Function "%s" modifies an input struct object "%s". ' ...
                'For better performance, make this object an output as well, '...
                'and when calling the function, use a same variable '...
                'on the left- and right-hand side for this argument.'], funname, toks{j}{2});
            continue;
        end
        
        if isempty( regexp( args, ['[^\w\s]\s*' toks{j}{1} '\w*\s*\*\s*' toks{j}{3}], 'once'))
            warning( [prog ':StructCopy'], 'Function "%s" copies a local struct object "%s".', funname, toks{j}{2});
            continue;
        end
        
        assert( ~isempty( regexp( fun, '\s+(?:\w+_)?emxCopyStruct_(\w+)\((\w+),\s*&(\w+)\);', 'once')));
        
        % Check whether there is assignment to itself
        if ~isempty( regexp(fun, [toks{j}{3} '->\w+([\w\[\]->\.])?\s*=\s*' toks{j}{2} '\.\w+([\w\[\]->\.])?;'], 'once')) || ...
                ~isempty( regexp(fun, [toks{j}{2} '\.\w+([\w\[\]->\.])?\s*=\s*' toks{j}{3} '->\w+([\w\[\]->\.])?;'], 'once'))
            warning( [prog ':StructCopy'], [prog ' Info: Function "%s" copies the output struct object "%s" into a local variable "%s". ' ...
                prog ' cannot optmize it. Please rewrite the MATLAB function to modify the object in a subfunction.'], ...
                funname, toks{j}{3}, toks{j}{2});
            continue;
        end
        
        body = regexprep( fun, ['\n\s+\w*emxCopyStruct_' toks{j}{1} '\w*\(' toks{j}{3} ',\s*\&' toks{j}{2} '\);'], char(187));
        smallbody = ['\n\s+\w*emxCopyStruct_' toks{j}{1} '\w*\(\&' toks{j}{2} ',\s*' toks{j}{3} '\);([^' char(187) ']+)' char(187)];
        
        body = regexp( body, smallbody, 'tokens');
        if isempty(body); continue; end
        
        hasinline = false;
        for k=1:length(body)
            if ~isempty(regexp(body{k}{1}, ['(\n\s+[^\n]*[^\w])' toks{j}{2} '\.(\w+)'], 'once'))
                warning( [prog ':StructCopyFailed'], ['Could not strip out copying of "' funname '", ' ...
                    'because the following inlined code "' body{k}{1} '". '...
                    'Please disable inlining by inserting coder.inline(''never'') into the MATLAB function corresponds to this code segment.']);
                hasinline = true;
                break;
            end
        end
        if hasinline; continue; end
        
        
        fprintf( 2, [prog ' Info: Function "%s" copies the output struct object "%s" into a local variable "%s". ' ...
            prog ' will try to strip out the copying for efficiency.\n\n'], funname, toks{j}{3}, toks{j}{2});
        
        % comment out declaration of the object
        fun = regexprep( fun, ['(\s\s+)(' toks{j}{1} '\w*\s+' toks{j}{2} ';)'], ['$1/*' prog ' $2*/']);
        fun = regexprep( fun, ['(\s\s+)(\w*emxInitStruct_' toks{j}{1} '\w*\(\&' toks{j}{2} '\);)'], ['$1/*' prog ' $2*/']);
        fun = regexprep( fun, ['(\s\s+)(\w*emxFreeStruct_' toks{j}{1} '\w*\(\&' toks{j}{2} '\);)'], ['$1/*' prog ' $2*/']);
        fun = regexprep( fun, ['(\n\s+)(\w*emxCopyStruct_' toks{j}{1} '\w*\(\&' toks{j}{2} ',\s*' toks{j}{3} '\);)'], ['$1/*' prog ' $2*/']);
        fun = regexprep( fun, ['(\n\s+)(\w*emxCopyStruct_' toks{j}{1} '\w*\(' toks{j}{3} ',\s*\&' toks{j}{2} '\);)'], ['$1/*' prog ' $2*/']);
        
        % Replace references of the object
        fun = regexprep( fun, ['(\n\s+[^\n]*[^\w])' toks{j}{2} '\.(\w+)'], ['$1' toks{j}{3} '->$2']);
        fun = regexprep( fun, ['(\n\s+([\w][^\n]*)?[^\w])&' toks{j}{2} '([^\w])'], ['$1' toks{j}{3} '$2']);
    end
    
    str = strrep( str, funcs{i}{3}, fun);
end
end

function check_inputArrays( str, prog)
% Check input constant arrays

funcs = regexp( str, ['(\w+)(\([^\)]+const emxArray_[^\)]+\))\s*(' funcbody ')'], 'tokens');

for i=1:length(funcs)
    % Check whether an argument is copied.
    funname = funcs{i}{1};
    args = funcs{i}{2};
    fun = funcs{i}{3};
    if ~isempty(strfind( funname, 'emlrt_')); continue; end
    
    toks = regexp( args, 'const emxArray_(\w+)\s*\*\s*(\w+)', 'tokens');
    for j=1:length(toks)
        
        % Check to see whether the array has a copy defined.
        if isempty( strfind( toks{j}{2}, '_')) && ~isempty( regexp( fun, ...
                ['\semxArray_' toks{j}{1} '\s*\*\s*\w+_' toks{j}{2} ';'], 'once'))
            warning( [prog ':ConstArrayCopyConst'], ['Function "%s" makes a copy of an input array "%s". ' ...
                'For better performance, make this array an output as well, '...
                'and when calling the function, use a same variable '...
                'on the left- and right-hand side for this argument.'], funname, toks{j}{2});
        end
    end
end
end

function check_localArrays( str, prog)
funcs = regexp( str, ['(\w+)(\([^\)]+\))\s*(' funcbody ')'], 'tokens');

if isequal(prog, 'm2mex')
    dir = 'mex';
else
    dir = 'lib';
end

for i=1:length(funcs)
    % Check whether an argument is copied.
    funname = funcs{i}{1};
    % args = funcs{i}{2};
    fun = funcs{i}{3};
    
    if ~isempty(strfind( funname, 'emlrt_')); continue; end
    toks = regexp( fun, '\s+emxEnsureCapacity\(\(emxArray__common \*\)(r[\d]+),\s*\w+,\s*\(int32_T\)', 'tokens');
    
    for j=1:length(toks)
        % Check to see whether the variables are used as local indices
        target = regexp( fun, ['\s+(\w+)->data\[\w+\] = [\w->]+->data\[' toks{j}{1} '->data\[\w+\] - 1\]'], 'tokens');
        if ~isempty( target)
            fprintf( 2, [prog ' Info: Function "%s" created a local integer buffer for the assignment of array "%s". '...
                'This probably indicates that you are assigning to a submatrix or a subvector of some variable size. ' ...
                'Current version of MATLAB Coder does not generate very efficient code for it. ' ...
                'Please review the generated C code codegen/%s/%s/%s.c and the MATLAB code, and consider replacing the assignment ' ...
                'in the MATLAB code with an explict for loop for better efficiency of the C code.\n'], ...
                funname, target{1}{1}, dir, funname, funname);
        else
            skip=false;
            for k=1:j-1
                if isequal(toks{j}{1},toks{k}{1}); skip=true; end
            end
            if skip;
                continue;
            end
            target = regexp( fun, [toks{j}{1} '->data\[\w+\] = ([\w->]+)->data\[\w+\]'], 'tokens');
            if ~isempty( target)
                fprintf( 2, [prog ' Info: Function "%s" created a local buffer as a local copy of array "%s".\n'], ...
                    funname, target{1}{1});
            else
                fprintf( 2, [prog ' Info: Function "%s" created a local buffer "%s".\n'], ...
                    funname, toks{j}{1});
            end
        end
    end
end

end

function check_intCasting( str, prog)

funcs = regexp( str, ['(\w+)(\([^\)]+\))\s*(' funcbody ')'], 'tokens');

for i=1:length(funcs)
    % Check whether an argument is copied.
    funname = funcs{i}{1};
    fun = funcs{i}{3};
    
    toks = regexp( fun, '(\w+)\s*=\s*\(int32_T\)floor\(', 'tokens');
    for j=1:length(toks)
        fprintf( 2, [prog ' Info: Function "%s" involves casting from a real value to integer variable "%s".\n'], ...
            funname, toks{j}{1});
    end
end
end


function str = read_file( filename)
fid = fopen(filename, 'rt');
if fid>=0
    str = fread( fid,'*char')';
    fclose( fid);
else
    warning('POST_CODEGEN:CannotOpenFile', 'Could not open file %s\n', filename);
    str = '';
end
end

function write_file( filename, str)
fid = fopen(filename, 'wt');
if fid>=0
    fwrite( fid, uint8( str'));
    fclose( fid);
end
end

function fb = funcbody
fb = '{(?:[^}][^\n]*\n)*\n*}';
end
