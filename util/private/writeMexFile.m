function writeMexFile(funcname, mpath, cpath, m2c_opts)

% TODO: Implement support for varargin, varargout, cell arrays, complex
%       numbers, global variables, and function pointers.

if m2c_opts.withNvcc
    altapis = {[funcname '_cuda0'], [funcname '_cuda1'], [funcname '_cuda2']};
else
    altapis = [funcname, strtrim(strrep(regexp(m2c_opts.codegenArgs, ...
        '(\w+)\s+-args', 'match'), ' -args', ''))];    
end

% Write out _mex file
if m2c_opts.withNvcc
    outMexFile = [cpath funcname '_mex.cpp'];
else
    outMexFile = [cpath funcname '_mex.' m2c_opts.suf];
end

[~, signature] = ckSignature(m2c_opts, 'codegen');

if cpath(1) == '/' || cpath(1) == '\'
    fname = [funcname '_mex.' m2c_opts.suf];
else
    fname = outMexFile;
end

if m2c_opts.withNvcc
    cudaheader = '#include "mcuda.h"';
else
    cudaheader = '';
end

filestr = sprintf('%s\n', ...
    '/*', [' * ' fname], ' *', ...
    [' * Auxiliary code for mexFunction of ' funcname], ' *', ...
    ' * C source code generated by m2c.', ...
    [' * ' signature], ...
    ' *', ' */', '', ...
    '#ifdef MATLAB_MEX_FILE', ...
    '#include "mex.h"',  ...
    '#else',  ...
    '#include "matrix.h"',  ...
    '#endif',  ...
    '/* Include the C header file generated by codegen in lib mode */', ...
    ['#include "' funcname '.h"'], ...
    '#include "m2c.c"', cudaheader, ...
    '/* Include declaration of some helper functions. */', ...
    '#include "lib2mex_helper.c"', '');

% Parse input arguments from C files.
alt_nlhs = zeros(length(altapis),1);
alt_nrhs = zeros(length(altapis),1);

if m2c_opts.withNvcc
    % Parse input arguments from C files.
    [vars, ret, nlhs, nrhs, SDindex, pruned_vars] = ...
        parse_cgfiles(funcname, funcname, mpath, cpath);
    vars_options = cuda_control_variables(nrhs);

    for i=1:length(altapis)
        if i>1
            nrhs = nrhs + 1;
            vars = [vars; vars_options(i-1)]; %#ok<AGROW>
        end
        filestr = sprintf('%s', filestr, printApiFunction(funcname, altapis{i}, ...
            nlhs, nrhs, vars, ret, SDindex, pruned_vars, m2c_opts.timing, m2c_opts.withNvcc));
        alt_nlhs(i) = nlhs; alt_nrhs(i) = nrhs;
    end
else
    for i=1:length(altapis)
        % Parse input arguments from C files.
        [vars, ret, nlhs, nrhs, SDindex, pruned_vars] = ...
            parse_cgfiles(funcname, altapis{i}, mpath, cpath);
        if ~isempty(SDindex)
            fprintf(2, ['m2c Info: Codegen generated a StackData object "' ...
                vars(SDindex).cname '" of type "' vars(SDindex).type '". ' ...
                'This probably indicates that you have some large, ', ...
                'fixed-size local buffers in some subroutines ' ...
                'that Codegen grouped into an object. See "' ...
                cpath funcname '_types.h" ' , ...
                'for the definition and content of the object.\n']);
        end
        filestr = sprintf('%s', filestr, printApiFunction(funcname, altapis{i}, ...
            nlhs, nrhs, vars, ret, SDindex, pruned_vars, m2c_opts.timing, m2c_opts.withNvcc));
        alt_nlhs(i) = nlhs; alt_nrhs(i) = nrhs;
    end
end

filestr = sprintf('%s', filestr, printMexFunction(altapis, alt_nlhs, alt_nrhs));

writeFile(outMexFile, filestr);

end

function str = printApiFunction(funcname, altname, nlhs, nrhs, vars, ...
    ret, SDindex, pruned_vars, timing, iscuda)
% Print into a string an API function for the function with the given
% numbers of input and output arguments.

if ~isempty(ret)
    retval = [ret.cname ' = '];
else
    retval = '';
end

vars_ret = [vars; ret];
if isempty(SDindex)
    SDname = '';
else
    SDname = ['&' vars(SDindex).cname];
end

%TODO: Improve computation of sub_mx_level_in and sub_mx_level_out
[marshallin_substr, sub_mx_level_in] = marshallin(altname, vars_ret, nlhs, nrhs, SDindex, iscuda);
[marshallout_substr, sub_mx_level_out] = marshallout(vars_ret, nlhs, pruned_vars, iscuda);
sub_mx_level = max(sub_mx_level_in, sub_mx_level_out);

str = sprintf('%s\n', ...
    ['static void __' altname '_api(mxArray **plhs, const mxArray ** prhs) {'], ...
    declare_vars(vars, ret, sub_mx_level, timing), ...
    marshallin_substr, '', '    /* Invoke the target function */');

if ~isempty(SDname)
    str = sprintf('%s%s\n', str, ...
        ['    ' funcname '_initialize(' SDname ');']);
end

if ~isempty(timing)
    str = sprintf('%s%s\n', str, '    _timestamp = M2C_wtime();');
end

str = sprintf('%s%s\n', str, ...
    ['    ' retval altname '(' listargs(vars) ');']);

if ~isempty(timing)
    str = sprintf('%s%s\n%s\n', str, ...
        '    _timestamp = M2C_wtime() - _timestamp;', ...
        ['    printf("Function ' funcname ' completed in %g seconds.\n", _timestamp);']);
end

if ~isempty(SDname)
    str = sprintf('%s%s\n', str, ...
        ['    ' funcname '_terminate();']);
end

str = sprintf('%s\n', str, ...
    marshallout_substr, '', var_free(vars_ret, iscuda), '}');

% Remove two consecutive empty lines
while ~isempty(regexp(str, '\n\n\n', 'once'))
    str = regexprep(str, '(\n\n)\n', '$1');
end

end

function str = printMexFunction(altapis, alt_nlhs, alt_nrhs)
% Print into a string a mexFunction for the function with the given
% numbers of input and output arguments.

str = 'void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {';

if max(alt_nlhs)>1
    str = sprintf('\n%s', ...
        str, '    /* Temporary copy for mex outputs. */', ...
        ['    mxArray *outputs[' int2str(max(alt_nlhs)) '];'], ...
        '    int i;', ...
        '    int nOutputs = (nlhs < 1 ? 1 : nlhs);', '');
end

haselse = '';
for i=1:length(altapis)
    funcname = altapis{i}; nlhs = alt_nlhs(i); nrhs = alt_nrhs(i);
    str = sprintf('\n%s', str, ...
        ['    ' haselse 'if (nrhs == ' int2str(nrhs) ') {'], ...
        ['        if (nlhs > ' int2str(nlhs) ')'], ...
        ['            mexErrMsgIdAndTxt("' funcname ':TooManyOutputArguments",'], ...
        ['                "Too many output arguments for entry-point ' funcname '.\n");']);
    if max(alt_nlhs)<=1
        str = sprintf('\n%s', str, ...
            '        /* Call the API function. */', ...
            ['        __' funcname '_api(plhs, prhs);'], '    }');
    else
        str = sprintf('\n%s', str, ...
            '        /* Call the API function. */', ...
            ['        __' funcname '_api(outputs, prhs);'], '    }');
    end
    
    haselse = 'else ';
end

str = sprintf('\n%s', str, ...
    '    else', ...
    ['        mexErrMsgIdAndTxt("' altapis{1} ':WrongNumberOfInputs",'], ...
    ['            "Incorrect number of input variables for entry-point ' altapis{1} '.");']);

if max(alt_nlhs)>1
    str = sprintf('\n%s', str, '', ...
        '    /* Copy over outputs to the caller. */', ...
        '    for (i = 0; i < nOutputs; ++i) {', ...
        '        plhs[i] = outputs[i];', ...
        '    }');
end

str = sprintf('\n%s', str, '}');

% Remove two consecutive empty lines
while ~isempty(regexp(str, '^\n\n', 'once'))
    str = regexprep(str, '^(\n)\n', '$1');
end
while ~isempty(regexp(str, '\n\n\n', 'once'))
    str = regexprep(str, '(\n\n)\n', '$1');
end

end

function str = declare_vars(vars, ret, sub_mx_level, timing)
% Produce variable declarations
decl_emx = '';
decl_basic = '';
decl_struct = '';
has_struct_arr = false;

for i=1:length(vars)
    if vars(i).isemx
        % declare a varialbe of type emxArray
        if ~isempty(vars(i).subfields)
            has_struct_arr=true;
        end
        if strncmp(vars(i).type, 'emxArray', 8)
            decl_emx = sprintf('%s\n    %-20s %s;', decl_emx, ...
                vars(i).type, vars(i).cname);
        elseif ~isempty(vars(i).sizefield) && isempty(vars(i).iindex)
            assert(~isempty(vars(i).modifier) && all(isfinite(vars(i).size)));
            decl_emx = sprintf('%s\n    %-20s %s[%d];', decl_emx, ...
                vars(i).type, vars(i).cname, prod(vars(i).size));
        else
            decl_emx = sprintf('%s\n    %-20s %s%s;', decl_emx, ...
                vars(i).type, vars(i).modifier, vars(i).cname);
        end
    elseif ~isempty(vars(i).subfields)
        if prod(vars(i).size)>1
            has_struct_arr=true;
        end
        
        % declare a variable of a struct type
        if prod(vars(i).size)==1
            decl_struct = sprintf('%s\n    %-20s %s;', decl_struct, ...
                vars(i).type, vars(i).cname);
        else
            decl_struct = sprintf('%s\n    %-20s %s[%d];', decl_struct, ...
                vars(i).type, vars(i).cname, prod(vars(i).size));
        end
        [~,b] = check_struct_levels(vars(i).subfields);
        
        has_struct_arr = has_struct_arr || b;
    elseif isequal(vars(i).type, 'char_T')
        % declare a varialbe of primitive type
        decl_basic = sprintf('%s\n    %-20s %s[%d];', decl_basic, ...
            'char', vars(i).cname, prod(vars(i).size));
    elseif prod(vars(i).size)>1 && ~any(vars(i).vardim)
        % declare a varialbe of primitive type
        decl_basic = sprintf('%s\n    %-20s %s[%d];', decl_basic, ...
            vars(i).type, vars(i).cname, prod(vars(i).size));
    else
        % declare a varialbe of primitive type
        decl_basic = sprintf('%s\n    %-20s %s%s;', decl_basic, ...
            vars(i).type, vars(i).modifier, vars(i).cname);
    end
end

if ~isempty(ret)
    decl_basic = sprintf('%s\n    %-20s %s%s;', decl_basic, ...
        ret.type, ret.modifier, ret.cname);
end

if sub_mx_level
    % declare a variable of a struct type
    if sub_mx_level>1; vstr = sprintf(', *_sub_mx%d', 2:sub_mx_level);
    else vstr = ''; end
    decl_struct = sprintf('%s\n    %-20s %s%s;', decl_struct, 'mxArray', '*_sub_mx1', vstr);
end

if has_struct_arr
    % declare variables for index
    decl_struct = sprintf('%s\n    %-20s _sub_k;', decl_struct, 'int32_T');
end

if ~isempty(timing);
    % declare variables for timing
    decl_timing = sprintf('    %-20s _timestamp;', 'real64_T');
else
    decl_timing = '';
end

str = sprintf('%s\n%s\n%s\n%s\n', decl_emx, decl_struct, decl_basic, decl_timing);

end

function [level,has_struct_arr] = check_struct_levels(vars, level)
% Check number of levels of a struct and whether it contains struct arrays
if nargin<2; level = 1; end

has_struct_arr = false;
for i=1:length(vars)
    if ~isempty(vars(i).subfields)
        [level,b] = check_struct_levels(vars(i).subfields, level+1);
        
        has_struct_arr = has_struct_arr || b || prod(vars(i).size)~=1;
    end
end
end

function [str, sub_mx_leve] = marshallin(funcname, vars, nlhs, nrhs, SDindex, iscuda)
% Marshall function input arguments and preallocate output arguments.

invarsindex = zeros(nrhs, 1);
outvarsindex = zeros(nlhs, 1);

for i=1:length(vars)
    if ~isempty(vars(i).iindex)
        invarsindex(vars(i).iindex) = i;
    end
    if ~isempty(vars(i).oindex)
        outvarsindex(vars(i).oindex) = i;
    end
end

sub_mx_leve = 0;
str = '';
first = true;
for j=1:nrhs
    i = invarsindex(j); assert(i>0);
    var = vars(i);
    
    if first
        str = '    /* Marshall in function inputs */';
        first = false;
    end
    
    if ~isempty(var.oindex)
        str = sprintf('%s\n', str, ...
            ['    plhs[' num2str(var.oindex-1) '] = mxDuplicateArray(prhs[' num2str(var.iindex-1) ']);']);
        mx = ['plhs[' int2str(var.oindex-1) ']'];
    else
        mx = ['prhs[' int2str(var.iindex-1) ']'];
    end
    
    if ~isempty(var.subfields)
        [str, sub_mx_leve] = marshallin_struct(str, mx, var, funcname);
    else
        if ~iscuda || isempty(var.modifier)
            str = sprintf(['%s\n    if (mxGetNumberOfElements(%s) && mxGetClassID(%s) != %s)\n', ...
                '        mexErrMsgIdAndTxt("%s:WrongInputType",\n',...
                '            "Input argument %s has incorrect data type; %s is expected.");'], ...
                str, mx, mx, getMxClassID(var.basetype), ...
                funcname, var.mname, getMatlabClass(var.basetype));
            
            if var.isemx
                for i=1:length(var.size)
                    if ~var.vardim(i)
                        str = sprintf(['%s\n    if (mxGetNumberOfElements(%s) && mxGetDimensions(%s)[%d] != %d)\n', ...
                            '        mexErrMsgIdAndTxt("%s:WrongSizeOfInputArg",\n',...
                            '            "Dimension %d of %s should be equal to %d.");'], ...
                            str, mx, mx, i-1, var.size(i), funcname, i, var.mname, var.size(i));
                    elseif isfinite(var.size(i))
                        str = sprintf(['%s\n    if (mxGetDimensions(%s)[%d] > %d)\n', ...
                            '        mexErrMsgIdAndTxt("%s:WrongSizeOfInputArg",\n',...
                            '            "Dimension %d of %s should be no more than %d.");'], ...
                            str, mx, i-1, var.size(i), funcname, i, var.mname, var.size(i));
                    end
                end
                if any(isinf(var.size)) && isempty(var.sizefield)
                    str = sprintf('%s\n    alias_mxArray_to_emxArray(%s, (emxArray__common *)&%s, "%s", %d);', ...
                        str, mx, var.cname, var.mname, length(var.size));
                elseif ~isempty(var.sizefield) && ~isempty(var.modifier)
                    str = sprintf('%s\n    %s = (%s*)mxGetData(%s);', ...
                        str, var.cname, var.basetype, mx);
                else
                    str = sprintf('%s\n    copy_mxArray_to_emxArrayStatic(%s, %s.data, %s.size, %d, "%s", %d);', ...
                        str, mx, var.cname, var.cname, length(var.size), var.mname, prod(var.size));
                end
            elseif prod(var.size)~=1
                assert(~any(var.vardim));
                for i=1:length(var.size)
                    str = sprintf(['%s\n    if (mxGetDimensions(%s)[%d] != %d)\n', ...
                        '        mexErrMsgIdAndTxt("%s:WrongSizeOfInputArg",\n',...
                        '            "Dimension %d of %s should be equal to %d.");'], ...
                        str, mx, i-1, var.size(i), funcname, i, var.mname, var.size(i));
                end
                assert(~isequal(var.type, 'char') && ~isequal(var.type, 'char_T'));
                str = sprintf('%s\n    copy_mxArray_to_array(%s, %s, %d);', ...
                    str, mx, var.cname, prod(var.size));
            else
                str = sprintf(['%s\n    if (mxGetNumberOfElements(%s) != 1)\n', ...
                    '        mexErrMsgIdAndTxt("%s:WrongSizeOfInputArg",\n',...
                    '            "Argument %s should be a scalar.");'], ...
                    str, mx, funcname, var.mname);
                if isempty(var.modifier)
                    if isequal(var.type, 'char_T') || isequal(var.type, 'char')
                        str = sprintf('%s\n    %s = *(mxChar*)mxGetData(%s);', ...
                            str, var.cname, mx);
                    else
                        str = sprintf('%s\n    %s = *(%s*)mxGetData(%s);', ...
                            str, var.cname, var.type, mx);
                    end
                else
                    str = sprintf('%s\n    %s = (%s*)mxGetData(%s);', ...
                        str, var.cname, var.type, mx);
                end
            end
        else
            str = sprintf('%s\n', str, ...
                ['    if (mxGetClassID(' mx ') == mxSTRUCT_CLASS && mxGetFieldNumber(' mx ', "type")==1) {'], ...
                '        char _type[64];', ...
                ['        mxGetString(mxGetFieldByNumber(' mx ', 0, 1), _type, 64);'], ...
                ['        if (strcmp(_type, "' getMatlabClass(var.basetype) '"))'], ...
                ['            mexErrMsgIdAndTxt("' funcname ':WrongInputType",'],...
                ['                "Input argument ' var.mname ' has incorrect data type; ' getMatlabClass(var.basetype) ' is expected.");'], ...
                ['         ' var.cname ' = *(' var.basetype '**)mxGetData(mxGetFieldByNumber(' mx ', 0, 0));'], ...
                '    } else {', ...
                ['        if (mxGetNumberOfElements(' mx ') && mxGetClassID(' mx ') != ' getMxClassID(var.basetype) ')'], ...
                ['            mexErrMsgIdAndTxt("' funcname ':WrongInputType",'], ...
                ['                "Input argument ' var.mname ' has incorrect data type; ' getMatlabClass(var.basetype) ' is expected.");'], ...
                ['        ' var.cname ' = (' var.basetype '*)create_gpuArray_from_mxArray(' mx ');'], ...
                '    }');
        end
    end
end

first = true;
% Preallocate output arguemnts that are arrays of fixed size
for j=1:nlhs
    if outvarsindex(j)==0
        continue;
    end
    
    var = vars(outvarsindex(j));
    if ~isempty(var.iindex); continue; end
    
    if first
        str = sprintf('%s\n\n%s', str, '    /* Preallocate output variables */');
        first = false;
    end
    
    assert(~iscuda || prod(var.size)==1);
    if var.isemx && any(isinf(var.size))
        str = sprintf('%s\n    init_emxArray((emxArray__common*)&%s, %d);', ...
            str, var.cname, length(var.size));
    elseif ~isempty(var.subfields)
        str = preallocate_struct(str, var.cname, var);
    elseif ~isempty(var.modifier) && prod(var.size)>0 && ~isequal(var.type, 'char_T')
        str = sprintf(['%s\n    {mwSize l_size[] = {', ...
            regexprep(strtrim(sprintf('%d ', var.size)), ' ', ', '), '};\n', ...
            '    *(void **)&%s = prealloc_mxArray((mxArray**)&plhs[%d], %s, %d, l_size); }'], ...
            str, var.cname, j-1, getMxClassID(var.basetype), length(var.size));
    end
end

% Preallocate StackData object
if ~isempty(SDindex)
    assert(~iscuda);
    var = vars(SDindex);
    sf = vars(SDindex).subfields;
    str = sprintf('%s\n\n%s\n    %s.%s = (%s *)mxMalloc(sizeof(%s));', str, ...
        '    /* Allocate Stack Data */', var.cname,sf.cname, sf.type, sf.type);
end

end

function str = preallocate_struct(str, cprefix, var, level)
% Pre-allocate output struct

if nargin<4; level=1; end
assert(~var.isemx);

substr = '';
indent = repmat('    ',1,level-1);
if prod(var.size)>1
    indent = repmat('    ',1,level);
end

for k=1:length(var.subfields)
    sf = var.subfields(k);
    if sf.isemx && ~isempty(sf.modifier)
        substr = sprintf(['%s\n%s    *(void **)&%s.%s = mxCalloc(1, sizeof(emxArray__common));', ...
            '%s    init_emxArray((emxArray__common*)%s.%s, %d);'], ...
            substr, indent, cprefix, sf.cname, indent, cprefix, sf.cname, length(sf.size));
    elseif ~isempty(sf.subfields)
        substr = preallocate_struct(substr, [cprefix '.' sf.cname], sf, level+1);
    end
end

if prod(var.size)>1 && ~isempty(substr)
    substr = sprintf('%s\n%s%s\n%s}', '', indent, ...
        'for (_sub_k=0; _sub_k<%d; ++_sub_k) {', substr, indent);
end

str = sprintf('%s%s', str, substr);
end

function [str, sub_mx_level] = marshallin_struct(str, mx, var, funcname, level, cprefix, mprefix)
if nargin<5; level=1; end
if nargin<6; cprefix=''; mprefix=''; end

indent = repmat('    ',1,level-1);

str = sprintf('%s\n', str);

% Check struct type and fields
str = sprintf(['%s\n%s    if (!mxIsStruct(%s))\n', ...
    '%s        mexErrMsgIdAndTxt("%s:WrongInputType",\n',...
    '%s            "Input argument %s has incorrect data type. struct is expected.");'], ...
    str, indent, mx, indent, funcname, indent, [mprefix var.mname]);
str = sprintf(['%s\n%s    if (mxGetNumberOfFields(%s)!=%d)\n', ...
    '%s        mexErrMsgIdAndTxt("%s:InputStructWrongFields",\n',...
    '%s            "Input argument %s has incorrect number of fields.");'], ...
    str, indent, mx, length(var.subfields), indent, funcname, indent, [mprefix var.mname]);
if all(isfinite(var.size)) && ~any(var.vardim)
    str = sprintf(['%s\n%s    if (mxGetNumberOfElements(%s) != %d)\n', ...
        '%s        mexErrMsgIdAndTxt("%s:WrongSizeOfInputArg",\n',...
        '%s            "Argument %s must contain %d items.");'], ...
        str, indent, mx, prod(var.size), indent, funcname, indent, var.mname, prod(var.size));
end

if var.isemx && any(isinf(var.size))
    str = sprintf('%s\n%s    init_emxArray_from_mxArray(%s, (emxArray__common*)&%s, "%s", %d, sizeof(%s));', ...
        str, indent, mx, [cprefix var.cname], [cprefix var.mname], length(var.size), var.structname);
    indent = repmat('    ',1,level);
    index = '_sub_k'; p = [[cprefix var.cname] '.data[_sub_k]' ];
elseif prod(var.size)>1
    indent = repmat('    ',1,level);
    index = '_sub_k'; p = [[cprefix var.cname] '[_sub_k]' ];
else
    index = '0'; p = [cprefix var.cname];
end

submx = ['_sub_mx' int2str(level)];
substr = '';
sub_mx_level = 0;
local_sub_mx_level = ~isempty(var.subfields);
for k=1:length(var.subfields)
    sf = var.subfields(k);
    
    % Check fields
    substr = sprintf('%s\n%s    %s = mxGetField(%s, %s, "%s");', ...
        substr, indent, submx, mx, index, sf.mname);
    substr = sprintf(['%s\n%s    if (%s==NULL)\n', ...
        '%s        mexErrMsgIdAndTxt("%s:WrongInputStruct",\n',...
        '%s            "Input argument %s does not have the field %s.");'], ...
        substr, indent, submx, indent, funcname, indent, [mprefix var.mname], sf.mname);
    
    substr = sprintf(['%s\n%s    if (mxGetNumberOfElements(%s) && mxGetClassID(%s) != %s)\n', ...
        '%s        mexErrMsgIdAndTxt("%s:WrongInputType",\n',...
        '%s            "Input argument %s.%s has incorrect data type. %s is expected.");'], ...
        substr, indent, submx, submx, getMxClassID(sf.basetype), indent, funcname, ...
        indent, [mprefix var.mname], sf.mname, getMatlabClass(sf.basetype));
    
    if sf.isemx
        for i=1:length(sf.size)
            if ~sf.vardim(i)
                substr = sprintf(['%s\n%s    if (mxGetNumberOfElements(%s) && mxGetDimensions(%s)[%d] != %d)\n', ...
                    '%s        mexErrMsgIdAndTxt("%s:WrongSizeOfInputArg",\n',...
                    '%s            "Dimension %d of %s.%s should be equal to %d.");'], ...
                    substr, indent, submx, submx, i-1, sf.size(i), indent, funcname, indent, ...
                    i, [mprefix var.mname], sf.mname, sf.size(i));
            elseif isfinite(sf.size(i))
                substr = sprintf(['%s\n%s    if (mxGetDimensions(%s)[%d] > %d)\n', ...
                    '%s        mexErrMsgIdAndTxt("%s:WrongSizeOfInputArg",\n',...
                    '%s            "Dimension %d %s.%s should be no more than %d.");'], ...
                    substr, indent, submx, i-1, sf.size(i), indent, funcname, indent, ...
                    i, [mprefix var.mname], sf.mname, sf.size(i));
            end
        end
        if ~isempty(sf.modifier)
            substr = sprintf('%s\n%s    *(void**)&%s.%s = mxCalloc(1, sizeof(emxArray__common));', ...
                substr, indent, p, var.subfields(k).cname);
            substr = sprintf('%s\n%s    alias_mxArray_to_emxArray(%s, (emxArray__common*)%s.%s, "%s.%s", %d);', ...
                substr, indent, submx, p, sf.cname, [mprefix var.mname], sf.mname, length(sf.size));
        else
            substr = sprintf('%s\n%s    copy_mxArray_to_emxArrayStatic(%s, %s.%s.data, %s.%s.size, %d, "%s.%s", %d);', ...
                substr, indent, submx, p, sf.cname, p, sf.cname, length(sf.size), [mprefix var.mname], sf.mname, prod(sf.size));
        end
    elseif ~isempty(var.subfields(k).subfields)
        [substr, sub_mx_level1] = marshallin_struct(substr, submx, var.subfields(k), ...
            funcname, level+1, [cprefix cvar.cname '.'], [mprefix cvar.mname '.']);
        sub_mx_level = max(sub_mx_level, sub_mx_level1);
    elseif prod(sf.size)>1
        assert(~isequal(sf.type, 'char') && ~isequal(sf.type, 'char_T'));
        for i=1:length(sf.size)
            substr = sprintf(['%s\n%s    if (mxGetNumberOfElements(%s) && mxGetDimensions(%s)[%d] != %d)\n', ...
                '%s        mexErrMsgIdAndTxt("%s:WrongSizeOfInputArg",\n',...
                '%s            "Dimension %d of %s.%s should be equal to %d.");'], ...
                substr, indent, submx, submx, i-1, sf.size(i), indent, funcname, indent, ...
                i, [mprefix var.mname], sf.mname, sf.size(i));
        end
        substr = sprintf('%s\n%s    copy_mxArray_to_array(%s, %s.%s, %d);', ...
            substr, indent, submx, p, sf.cname, prod(sf.size));
    else
        substr = sprintf(['%s\n%s    if (mxGetNumberOfElements(%s) != 1)\n', ...
            '%s        mexErrMsgIdAndTxt("%s:WrongSizeOfInputArg",\n',...
            '%s            "Argument %s.%s should be a scalar.");'], ...
            substr, indent, submx, indent, funcname, indent, [mprefix var.mname], sf.mname);
        substr = sprintf('%s\n%s    %s.%s = *(%s*)mxGetData(%s);', ...
            substr, indent, p, sf.cname, sf.type, submx);
    end
end

%
if ~isempty(substr)
    if var.isemx
        indent = repmat('    ',1,level);
        str = sprintf('%s\n%sfor (_sub_k=mxGetNumberOfElements(%s)-1; _sub_k>=0; --_sub_k) {%s\n%s}', ...
            str, indent, mx, substr, indent);
    elseif prod(var.size)>1
        indent = repmat('    ',1,level);
        str = sprintf('%s\n%sfor (_sub_k=0; _sub_k<%d; ++_sub_k) {%s\n%s}', ...
            str, indent, prod(var.size), substr, indent);
    else
        str = sprintf('%s\n%s', str, substr);
    end
end

sub_mx_level = sub_mx_level + local_sub_mx_level;

end

function str = listargs(vars)
% List the arguments for calling the function

str = '';
for i=1:length(vars)
    if vars(i).isemx
        if strncmp(vars(i).type, 'emxArray', 8)
            str = sprintf('%s, &%s', str, vars(i).cname);
        else
            str = sprintf('%s, %s', str, vars(i).cname);
        end
    elseif ~isempty(vars(i).subfields)
        if ~isempty(vars(i).modifier) && prod(vars(i).size)==1
            modifier='&';
        else
            modifier='';
        end
        str = sprintf('%s, %s%s', str, modifier, vars(i).cname);
    else
        str = sprintf('%s, %s', str, vars(i).cname);
    end
end

str = str(3:end);
end

function [str,sub_mx_level] = marshallout(vars, nlhs, pruned_vars, iscuda)
% Marshall function output arguments

sub_mx_level = 0;

if nlhs==0;
    str='';
    return;
else
    str = '    /* Marshall out function outputs */';
end

outvarsindex = zeros(nlhs, 1);
for i=1:length(vars)
    if ~isempty(vars(i).oindex)
        outvarsindex(vars(i).oindex) = i;
    end
end

for j=1:nlhs
    pruned = 0;
    if outvarsindex(j)==0
        for k=1:length(pruned_vars)
            if pruned_vars(k).oindex==j
                pruned = k;
                var = pruned_vars(k);
                break;
            end
        end
    else
        var = vars(outvarsindex(j));
    end
    
    if pruned
        str = sprintf('%s\n    /* Creating empty mxArray for pruned variable %s */', str, var.mname);
        str = sprintf(['%s\n    {mwSize l_size[] = {', ...
            regexprep(strtrim(sprintf('%d ', var.size)), ' ', ', '), '};\n', ...
            '    prealloc_mxArray((mxArray**)&plhs[%d], %s, %d, l_size); }'], ...
            str, j-1, ['mx' upper(var.type) '_CLASS'], length(var.size));
    elseif ~isempty(var.subfields)
        [str,sub_mx_level1] = marshallout_struct(str, sprintf('plhs[%d]', j-1), var);
        sub_mx_level = max(sub_mx_level, sub_mx_level1);
    elseif ~isempty(var.iindex) && var.isemx && iscuda
        str = sprintf('%s\n', str, ...
            ['    if (mxGetClassID(plhs[' num2str(j-1) ']) != mxSTRUCT_CLASS)'], ...
            ['        copy_gpuArray_to_mxArray(' var.cname ', plhs[' num2str(j-1) ']);']);
    elseif ~isempty(var.iindex) && var.isemx && any(isinf(var.size)) && isempty(var.sizefield)
        str = sprintf('%s\n', str, ...
            ['    if (' var.cname '.canFreeData) {'], ...
            ['        mxDestroyArray(plhs[' num2str(j-1) ']);'], ...
            ['        plhs[' num2str(j-1) '] = move_emxArray_to_mxArray((emxArray__common*)&' ...
            var.cname ', ' getMxClassID(var.basetype) ');'], ...
            '    }');
    elseif var.isemx
        if all(isfinite(var.size)) && any(var.vardim)
            if ~isempty(var.sizefield) && isempty(var.iindex)
                str = sprintf('%s\n', str, ...
                    ['    plhs['  num2str(j-1) '] = copy_array_to_mxArray(' ...
                    var.cname ', ' getMxClassID(var.basetype) ', ' ...
                    num2str(vars(var.sizefield).size) ', ' vars(var.sizefield).cname ');']);
            elseif ~isempty(var.sizefield)
                % Need to resize a preallocated varilable-length array
                str = sprintf('%s\n', str, ...
                    ['    resize_mxArray(plhs[' num2str(j-1) '], ' ...
                    num2str(vars(var.sizefield).size) ', ' vars(var.sizefield).cname ');']);
            else
                assert(isempty(var.modifier));
                str = sprintf('%s\n', str, ...
                    ['    plhs['  num2str(j-1) '] = copy_array_to_mxArray(' ...
                    var.cname '.data, ' getMxClassID(var.basetype) ', ' ...
                    num2str(length(var.size)) ', ' var.cname '.size);']);
            end
        elseif all(isfinite(var.size))
            sz = var.size;
            sz_str = sprintf(', %d', sz); sz_str = sz_str(3:end);
            
            str = sprintf('%s\n', str, ...
                ['    {int32_T l_size[] = {' sz_str '};'], ...
                ['    plhs[' num2str(j-1) '] = copy_array_to_mxArray(' var.cname ...
                ', ' getMxClassID(var.basetype) ', ' num2str(length(sz)) ', l_size); }']);
        elseif isempty(var.sizefield)
            str = sprintf('%s\n', str, ...
                ['    plhs[' num2str(j-1) '] = move_emxArray_to_mxArray((emxArray__common*)&' ...
                var.cname ', ' getMxClassID(var.basetype) ');']);
        end
    elseif isempty(var.modifier)
        str = sprintf('%s\n    plhs[%d] = copy_scalar_to_mxArray(&%s, %s);', ...
            str, j-1, var.cname, getMxClassID(var.basetype));
    elseif isequal(var.type, 'char_T')
        assert(isempty(var.sizefield));
        str = sprintf(['%s\n    {int32_T l_size[] = {', ...
            regexprep(strtrim(sprintf('%d ', var.size)), ' ', ', '), '};\n', ...
            '    plhs[%d] = copy_array_to_mxArray(%s, %s, %d, l_size); }'], ...
            str, j-1, var.cname, getMxClassID(var.basetype), length(var.size));
    else
        str = sprintf('%s\n    /* Nothing to do for plhs[%d] */', str, j-1);
    end
end
end

function [str,sub_mx_level] = marshallout_struct(str, mx, var, level, cprefix, mprefix)
% sub_mx_level is needed for determining the levels of _sub_mx

if nargin<4; level=1; end
if nargin<5; cprefix=''; mprefix=''; end

indent = repmat('    ',1,level-1);

str = sprintf('%s\n%s    {const char *_fields[] = { %s ""};', ...
    str, indent, sprintf('"%s", ', var.subfields.mname));

if var.isemx
    str = sprintf('%s\n%s    %s = create_struct_mxArray(%s.numDimensions, %s.size, %d, _fields);}', ...
        str, indent, mx, [cprefix var.cname], [cprefix var.cname], length(var.subfields));
    indent = repmat('    ',1,level); index='_sub_k'; sub='.data[_sub_k]';
elseif prod(var.size)>1
    sz_str = sprintf(', %d', var.size); sz_str = sz_str(3:end);
    
    str = sprintf(['%s\n%s    int32_T l_size[] = {%s};' ...
        '\n%s    %s = create_struct_mxArray(%d, l_size, %d, _fields);}'], ...
        str, indent, sz_str, indent, mx, length(var.size), length(var.subfields));
    indent = repmat('    ',1,level); index='_sub_k'; sub='[_sub_k]';
else
    str = sprintf('%s\n%s    int32_T _one=1;\n%s    %s = create_struct_mxArray(1, &_one, %d, _fields);}', ...
        str, indent, indent, mx, length(var.subfields));
    index='0';  sub='';
end

sub_mx_level = 0;
local_sub_mx_level = ~isempty(var.subfields);
substr = '';
for k=1:length(var.subfields)
    sf = var.subfields(k);
    sfcname = sf.cname; sfmname = sf.mname;
    if ~isempty(sf.subfields)
        [substr,sub_mx_level1] = marshallout_struct(substr, ['_sub_mx' int2str(level)], ...
            sf, level+1, [cprefix var.cname sub '.'], [mprefix var.mname sub '.']);
        substr = sprintf('%s\n%s    mxSetFieldByNumber((mxArray*)(%s), %s, %d, _sub_mx%d);', ...
            substr, indent, mx, index, k-1, level);
        sub_mx_level = max(sub_mx_level, sub_mx_level1);
    elseif sf.isemx
        if isempty(sf.modifier)
            ref = '.';
        else
            ref = '->';
        end
        if all(isfinite(sf.size)) && any(sf.vardim)
            substr = sprintf(['%s\n' ...
                '    mxSetFieldByNumber((mxArray*)(%s), %s, %d, ' ...
                'copy_array_to_mxArray(%s%s.%s%sdata, %s, %d, %s%s.%s%ssize));'], ...
                substr, mx, index, k-1, [cprefix var.cname], sub, sfcname, ref, ...
                getMxClassID(sf.basetype), length(sf.size), ...
                [mprefix var.mname], sub, sfmname, ref);
        elseif all(isfinite(sf.size))
            sz = sf.size;
            sz_str = sprintf(', %d', sz); sz_str = sz_str(3:end);
            
            substr = sprintf(['%s\n%s    {int32_T l_size[] = {%s};\n' ...
                '%s    mxSetFieldByNumber((mxArray*)(%s), %s, %d, ' ...
                'copy_array_to_mxArray(%s%s.%s%sdata, %s, %d, l_size)); }'], ...
                substr, indent, sz_str, indent, mx, index, k-1, ...
                [cprefix var.cname], sub, sfcname, ref, getMxClassID(sf.basetype), length(sz));
        else
            substr = sprintf(['%s\n%s    mxSetFieldByNumber((mxArray*)(%s), %s, %d, ' ...
                'move_emxArray_to_mxArray((emxArray__common*)%s%s.%s, %s));'], ...
                substr, indent, mx, index, k-1, [cprefix var.cname], sub, ...
                sfcname, getMxClassID(sf.basetype));
        end
    elseif prod(sf.size)==1
        substr = sprintf(['%s\n%s    mxSetFieldByNumber((mxArray*)(%s), %s, %d, ' ...
            'copy_scalar_to_mxArray(&%s%s.%s, %s));'], ...
            substr, indent, mx, index, k-1, [cprefix var.cname], sub, sfcname, getMxClassID(sf.basetype));
    elseif ~isempty(sf.sizefield) && isstruct(sf.sizefield)
        % Not yet debugged
        substr = sprintf(['%s\n' ...
            '%s    mxSetFieldByNumber((mxArray*)(%s), %s, %d, ' ...
            'copy_array_to_mxArray(%s%s.%s, %s, %d, %s%s.%s));'], ...
            substr, indent, mx, index, k-1, [cprefix var.cname], ...
            sub, sfcname, getMxClassID(sf.basetype), ...
            var.subfields(sf.sizefield).size, ...
            [cprefix var.cname], sub, var.subfields(sf.sizefield).cname);
    else
        sz = sf.size;
        sz_str = sprintf(', %d', sz); sz_str = sz_str(3:end);
        
        substr = sprintf(['%s\n%s    {int32_T l_size[] = {%s};\n' ...
            '%s    mxSetFieldByNumber((mxArray*)(%s), %s, %d, ' ...
            'copy_array_to_mxArray(%s%s.%s, %s, %d, l_size)); }'], ...
            substr, indent, sz_str, indent, mx, index, k-1, [cprefix var.cname], ...
            sub, sfcname, getMxClassID(sf.basetype), length(sz));
    end
end

if ~isempty(substr)
    if var.isemx
        str = sprintf('%s\n%sfor (_sub_k=mxGetNumberOfElements(%s)-1; _sub_k>=0; --_sub_k) {%s\n%s}', ...
            str, indent, mx, substr, indent);
    elseif prod(var.size)>1
        str = sprintf('%s\n%sfor (_sub_k=0; _sub_k<%d; ++_sub_k) {%s\n%s}', ...
            str, indent, prod(var.size), substr, indent);
    else
        str = sprintf('%s%s', str, substr);
    end
end

sub_mx_level = sub_mx_level + local_sub_mx_level;
end

function str = var_free(vars, iscuda)
% Print out free_emxArray for given variable

has_emxArray = false;

fvstr = '';
if ~iscuda
    for i=1:length(vars)
        if ~isempty(vars(i).subfields)
            [fvstr,hasa] = deallocate_struct(fvstr, '', vars(i));
            has_emxArray = has_emxArray || hasa;
        elseif strncmp(vars(i).type, 'emxArray_', 9) && any(isinf(vars(i).size))
            fvstr = sprintf('%s\n    free_emxArray((emxArray__common*)&%s);', ...
                fvstr, vars(i).cname);
            has_emxArray = true;
        end
    end
else
    for i=1:length(vars)
        if ~isempty(vars(i).modifier)
            assert(~isempty(vars(i).iindex));
            
            fvstr = sprintf('%s\n%s', fvstr, ...
                ['    if (mxGetClassID(prhs[' num2str(vars(i).iindex-1) ']) != mxSTRUCT_CLASS)', ...
                ' cudaFree(' vars(i).cname ');']);
            has_emxArray = true;
        end
    end
end

if has_emxArray;
    str = sprintf('    /* Free temporary variables */%s', fvstr);
else
    str = '';
end
end

function [str, has_emxArray] = deallocate_struct(str, cprefix, var, level)
% Deallocate output struct

if nargin<4; level=1; end
indent = repmat('    ', 1, level-1);

substr = '';

if strncmp(var.type, 'emxArray_', 9)
    has_emxArray = true;
    varname = [cprefix var.cname '.data[_sub_k].'];
    indent = repmat('    ', 1, level);
else
    has_emxArray = false;
    if prod(var.size)>1
        varname = [cprefix var.cname '[_sub_k].'];
        indent = repmat('    ', 1, level);
    else
        varname = [cprefix var.cname '.'];
    end
end

for k=1:length(var.subfields)
    sf = var.subfields(k);
    if sf.isemx && ~isempty(sf.modifier)
        substr = sprintf('%s    free_emxArray((emxArray__common*)%s%s); mxFree(%s%s);\n%s', ...
            indent, varname, sf.cname, varname, sf.cname, substr);
        has_emxArray = true;
    elseif ~isempty(sf.subfields)
        [substr, has_subemx] = deallocate_struct(substr, varname, sf, level+1);
        has_emxArray = has_emxArray || has_subemx;
    end
end

if isempty(substr); return; end

if strncmp(var.type, 'emxArray_', 9)
    str = sprintf('%s\n%sfor (_sub_k=nelems_emxArray((emxArray__common*)&%s)-1; _sub_k>=0; --_sub_k) {\n%s\n%s}', ...
        str, indent, [cprefix var.cname], substr, indent);
elseif prod(var.size)>1
    str = sprintf('%s\n%sfor (_sub_k=0; _sub_k<%d; ++_sub_k) {\n%s\n%s}', ...
        str, indent, prod(var.size), substr, indent);
else
    str = sprintf('%s\n%s', str, substr);
end
end

function opts = cuda_control_variables(nrhs)
% Control varilables for CUDA
nthreads = struct('cname', '_nthreads', 'mname', 'nthreads', ...
    'type', 'int32_T', 'basetype', 'int32_T', ...
    'structname', '', 'modifier', '', 'isconst', false, 'subfields', [], ...
    'isemx', false, 'size', 1, 'vardim', 0, 'sizefield', [], ...
    'iindex', nrhs+1, 'oindex', []);

threadsPB = struct('cname', '_threadsPB', 'mname', 'threadsPB', ...
    'type', 'int32_T', 'basetype', 'int32_T', ...
    'structname', '', 'modifier', '', 'isconst', false, 'subfields', [], ...
    'isemx', false, 'size', 1, 'vardim', 0, 'sizefield', [], ...
    'iindex', nrhs+2, 'oindex', []);

opts = [nthreads, threadsPB];
    
end
    


